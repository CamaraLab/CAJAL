(* Generated by futhark-bindgen *)

open! Signed
open! Unsigned

type error = 
  | InvalidShape of int * int 
  | NullPtr 
  | Code of int
  | UseAfterFree of [`context | `array | `opaque]

exception Error of error

module Context: sig
  type t
  (** Futhark context *)

  val v: ?debug:bool -> ?log:bool -> ?profile:bool -> ?cache_file:string -> ?auto_sync:bool -> ?num_threads:int -> unit -> t
  (** Create a new context *)
  
  val sync: t -> unit
  (** Sync the context, if auto_sync is enabled this is not needed *)
  
  val free: t -> unit
  (** Free the context *)
  
  val clear_caches: t -> unit
  (** Clear Futhark caches *)

  val get_error: t -> string option
  (** Get last error message or None *)

  val report: t -> string option
  val pause_profiling: t -> unit
  val unpause_profiling: t -> unit
end
module Array_f64_3d: sig
  type t
  (** Futhark array *)

  type kind = (float, Bigarray.float64_elt) Bigarray.kind
  (** The Bigarray kind that matches the correct element type for this array *)

  val kind: kind

  val shape: t -> int array
  (** Array shape *)

  val v: Context.t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Genarray.t -> t
  (** Initialize an array with the data from the provided bigarray *)

  val values: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Genarray.t -> unit
  (** Load the values into the provided bigarray *)

  val values_array1: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array1.t -> unit
  (** Similar to [values] but takes an [Array1] instead of [Genarray] *)

  val get: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Genarray.t
  (** Get a new bigarray with the values loaded *)

  val get_array1: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array1.t
  (** Similar to [get] but returns an [Array1] *)

  val of_array: Context.t -> int array -> (float) array -> t
  (** Create [t] from an array of values *)

  val of_array1: Context.t -> int array ->  (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array1.t-> t
  (** Create [t] from an [Array1] instead of [Genarray] *)

  val free: t -> unit
  (** Free the array *)
end

module Array_f64_2d: sig
  type t
  (** Futhark array *)

  type kind = (float, Bigarray.float64_elt) Bigarray.kind
  (** The Bigarray kind that matches the correct element type for this array *)

  val kind: kind

  val shape: t -> int array
  (** Array shape *)

  val v: Context.t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Genarray.t -> t
  (** Initialize an array with the data from the provided bigarray *)

  val values: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Genarray.t -> unit
  (** Load the values into the provided bigarray *)

  val values_array1: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array1.t -> unit
  (** Similar to [values] but takes an [Array1] instead of [Genarray] *)

  val get: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Genarray.t
  (** Get a new bigarray with the values loaded *)

  val get_array1: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array1.t
  (** Similar to [get] but returns an [Array1] *)

  val of_array: Context.t -> int array -> (float) array -> t
  (** Create [t] from an array of values *)

  val of_array1: Context.t -> int array ->  (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array1.t-> t
  (** Create [t] from an [Array1] instead of [Genarray] *)

  val free: t -> unit
  (** Free the array *)
end

module Array_f64_1d: sig
  type t
  (** Futhark array *)

  type kind = (float, Bigarray.float64_elt) Bigarray.kind
  (** The Bigarray kind that matches the correct element type for this array *)

  val kind: kind

  val shape: t -> int array
  (** Array shape *)

  val v: Context.t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Genarray.t -> t
  (** Initialize an array with the data from the provided bigarray *)

  val values: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Genarray.t -> unit
  (** Load the values into the provided bigarray *)

  val values_array1: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array1.t -> unit
  (** Similar to [values] but takes an [Array1] instead of [Genarray] *)

  val get: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Genarray.t
  (** Get a new bigarray with the values loaded *)

  val get_array1: t -> (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array1.t
  (** Similar to [get] but returns an [Array1] *)

  val of_array: Context.t -> int array -> (float) array -> t
  (** Create [t] from an array of values *)

  val of_array1: Context.t -> int array ->  (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array1.t-> t
  (** Create [t] from an [Array1] instead of [Genarray] *)

  val free: t -> unit
  (** Free the array *)
end

(** Entry point: ugw_armijo *)
val ugw_armijo: Context.t -> float -> float -> float -> Array_f64_2d.t -> Array_f64_1d.t -> Array_f64_2d.t -> Array_f64_1d.t -> float -> float -> float -> float -> (Array_f64_1d.t)

(** Entry point: ugw_armijo_euclidean *)
val ugw_armijo_euclidean: Context.t -> float -> float -> float -> Array_f64_3d.t -> float -> float -> float -> float -> (Array_f64_2d.t)

(** Entry point: ugw_armijo_pairwise *)
val ugw_armijo_pairwise: Context.t -> float -> float -> float -> Array_f64_3d.t -> Array_f64_2d.t -> float -> float -> float -> float -> (Array_f64_2d.t)

(** Entry point: ugw_armijo_pairwise_increasing *)
val ugw_armijo_pairwise_increasing: Context.t -> Array_f64_2d.t -> float -> float -> float -> float -> Array_f64_3d.t -> Array_f64_2d.t -> float -> float -> float -> float -> (Array_f64_2d.t)

(** Entry point: ugw_armijo_pairwise_unif *)
val ugw_armijo_pairwise_unif: Context.t -> float -> float -> float -> Array_f64_3d.t -> float -> float -> float -> float -> (Array_f64_2d.t)

