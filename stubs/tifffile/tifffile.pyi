import collections
import datetime
import enum
import numpy
import os
import threading
from _typeshed import Incomplete
from numpy import ndarray as ArrayLike
from typing import Any, BinaryIO, Callable, Collection, Container, ItemsView, Iterable, Iterator, KeysView, Literal, Mapping, Optional, Sequence, TextIO, Tuple, Union, ValuesView, overload

OutputType = Union[str, BinaryIO, numpy.ndarray, None]
TagTuple = Tuple[Union[int, str], Union[int, str], Optional[int], Any, bool]

ByteOrder = Union[Literal['>'], Literal['<']]


def imread(
        files: Union[str, os.PathLike, FileHandle, BinaryIO, Sequence[Union[str, os.PathLike]], None] = ...,
        *,
        aszarr: bool = ...,
        key: Union[int, slice, Iterable[int], None] = ...,
        series: Union[int, None] = ...,
        level: Union[int, None] = ...,
        squeeze: Union[bool, None] = ...,
        maxworkers: Union[int, None] = ...,
        mode: Union[Literal['r', 'r+'], None] = ...,
        name: Union[str, None] = ...,
        offset: Union[int, None] = ...,
        size: Union[int, None] = ...,
        pattern: Union[str, None] = ...,
        axesorder: Union[Sequence[int], None] = ...,
        categories: Union[dict[str, dict[str, int]], None] = ...,
        imread: Union[Callable[..., numpy.ndarray], None] = ...,
        sort: Union[Callable[..., Any], bool, None] = ...,
        container: Union[str, os.PathLike, None] = ...,
        axestiled: Union[dict[int, int], Sequence[tuple[int, int]], None] = ...,
        ioworkers: int = ...,
        chunkmode: Union[CHUNKMODE, int, str, None] = ...,
        fillvalue: Union[int, float, None] = ...,
        zattrs: Union[dict[str, Any], None] = ...,
        multiscales: Union[bool, None] = ...,
        omexml: Union[str, None] = ...,
        out: OutputType = ...,
        _multifile: Union[bool, None] = ...,
        _useframes: Union[bool, None] = ..., **kwargs
       ) -> Union[numpy.ndarray, ZarrTiffStore, ZarrFileSequenceStore]: ...

def imwrite(file: Union[str, os.PathLike, FileHandle, BinaryIO],
            data: Union[ArrayLike, Iterator[Union[numpy.ndarray, None]], Iterator[bytes], None] = ...,
            *,
            bigtiff: Union[bool, None] = ...,
            byteorder: Union[ByteOrder, None] = ...,
            imagej: bool = ...,
            ome: Union[bool, None] = ...,
            shaped: Union[bool, None] = ...,
            append: bool = ...,
            shape: Union[Sequence[int], None] = ...,
            dtype: Union[numpy.dtype, str, None] = ...,
            photometric: Union[PHOTOMETRIC, int, str, None] = ...,
            planarconfig: Union[PLANARCONFIG, int, str, None] = ...,
            extrasamples: Union[Sequence[Union[EXTRASAMPLE, int, str]], None] = ...,
            volumetric: bool = ...,
            tile: Union[Sequence[int], None] = ...,
            rowsperstrip: Union[int, None] = ...,
            bitspersample: Union[int, None] = ...,
            compression: Union[COMPRESSION, int, str, None] = ...,
            compressionargs: Union[dict[str, Any], None] = ...,
            predictor: Union[PREDICTOR, int, str, bool, None] = ...,
            subsampling: Union[tuple[int, int], None] = ...,
            jpegtables: Union[bytes, None] = ...,
            colormap: Union[ArrayLike, None] = ...,
            description: Union[str, bytes, None] = ...,
            datetime: Union[str, bool, None] = ...,
            resolution: Union[tuple[Union[float, tuple[int, int]], Union[float, tuple[int, int]]], None] = ...,
            resolutionunit: Union[RESUNIT, int, str, None] = ...,
            subfiletype: Union[FILETYPE, int, None] = ...,
            software: Union[str, bytes, bool, None] = ...,
            metadata: Union[dict[str, Any], None] = ...,
            extratags: Union[Sequence[TagTuple], None] = ...,
            contiguous: bool = ...,
            truncate: bool = ...,
            align: Union[int, None] = ...,
            maxworkers: Union[int, None] = ...,
            returnoffset: bool = ...
            ) -> Union[tuple[int, int], None]: ...

def imsave(*args, **kwargs) -> None: ...

def memmap(filename: Union[str, os.PathLike],
           *,
           shape: Union[Sequence[int], None] = ...,
           dtype: Union[numpy.dtype, None] = ...,
           page: Union[int, None] = ...,
           series: int = ...,
           level: int = ...,
           mode: Literal['r+', 'r', 'c'] = ...,
           **kwargs
           ) -> numpy.memmap: ...

class TiffFileError(Exception): ...

class TiffWriter:
    tiff: TiffFormat
    def __init__(self, file: Union[str, os.PathLike, FileHandle, BinaryIO], *, bigtiff: bool = ..., byteorder: Union[ByteOrder, None] = ..., append: bool = ..., imagej: bool = ..., ome: Union[bool, None] = ..., shaped: Union[bool, None] = ...) -> None: ...
    def write(self, data: Union[ArrayLike, Iterator[Union[numpy.ndarray, None]], Iterator[bytes], None] = ..., *, shape: Union[Sequence[int], None] = ..., dtype: Union[numpy.dtype, str, None] = ..., photometric: Union[PHOTOMETRIC, int, str, None] = ..., planarconfig: Union[PLANARCONFIG, int, str, None] = ..., extrasamples: Union[Sequence[Union[EXTRASAMPLE, int, str]], None] = ..., volumetric: bool = ..., tile: Union[Sequence[int], None] = ..., rowsperstrip: Union[int, None] = ..., bitspersample: Union[int, None] = ..., compression: Union[COMPRESSION, int, str, None] = ..., compressionargs: Union[dict[str, Any], None] = ..., predictor: Union[PREDICTOR, int, str, bool, None] = ..., subsampling: Union[tuple[int, int], None] = ..., jpegtables: Union[bytes, None] = ..., colormap: Union[ArrayLike, None] = ..., description: Union[str, bytes, None] = ..., datetime: Union[str, bool, None] = ..., resolution: Union[tuple[Union[float, tuple[int, int]], Union[float, tuple[int, int]]], None] = ..., resolutionunit: Union[RESUNIT, int, str, None] = ..., subfiletype: Union[FILETYPE, int, None] = ..., software: Union[str, bytes, bool, None] = ..., subifds: Union[int, Sequence[int], None] = ..., metadata: Union[dict[str, Any], None] = ..., extratags: Union[Sequence[TagTuple], None] = ..., contiguous: bool = ..., truncate: bool = ..., align: Union[int, None] = ..., maxworkers: Union[int, None] = ..., returnoffset: bool = ...): ...
    def save(self, *args, **kwargs) -> None: ...
    def overwrite_description(self, description: str) -> None: ...
    def close(self) -> None: ...
    @property
    def filehandle(self) -> FileHandle: ...
    def __enter__(self) -> TiffWriter: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...

class TiffFile:
    tiff: TiffFormat
    pages: TiffPages
    is_ome: bool
    def __init__(self, file: Union[str, os.PathLike, FileHandle, BinaryIO], *, mode: Union[Literal['r', 'r+'], None] = ..., name: Union[str, None] = ..., offset: Union[int, None] = ..., size: Union[int, None] = ..., omexml: Union[str, None] = ..., _multifile: Union[bool, None] = ..., _useframes: Union[bool, None] = ..., _parent: Union[TiffFile, None] = ..., **is_flags: dict[str, Union[bool, None]]) -> None: ...
    @property
    def byteorder(self) -> Literal['>', '<']: ...
    @property
    def filehandle(self) -> FileHandle: ...
    @property
    def filename(self) -> str: ...
    def fstat(self) -> Any: ...
    def close(self) -> None: ...
    def asarray(self, key: Union[int, slice, Iterable[int], None] = ..., *, series: Union[int, TiffPageSeries, None] = ..., level: Union[int, None] = ..., squeeze: Union[bool, None] = ..., out: OutputType = ..., maxworkers: Union[int, None] = ...) -> numpy.ndarray: ...
    def aszarr(self, key: Union[int, None] = ..., *, series: Union[int, TiffPageSeries, None] = ..., level: Union[int, None] = ..., **kwargs) -> ZarrTiffStore: ...
    def series(self) -> list[TiffPageSeries]: ...
    def __getattr__(self, name: str) -> bool: ...
    def __enter__(self) -> TiffFile: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def flags(self) -> set[str]: ...
    def is_uniform(self) -> bool: ...
    @property
    def is_appendable(self) -> bool: ...
    @property
    def is_bigtiff(self) -> bool: ...
    @property
    def is_ndtiff(self) -> bool: ...
    def is_mdgel(self) -> bool: ...
    def shaped_metadata(self) -> Union[tuple[dict[str, Any], ...], None]: ...
    @property
    def ome_metadata(self) -> Union[str, None]: ...
    @property
    def scn_metadata(self) -> Union[str, None]: ...
    @property
    def philips_metadata(self) -> Union[str, None]: ...
    @property
    def lsm_metadata(self) -> Union[dict[str, Any], None]: ...
    def stk_metadata(self) -> Union[dict[str, Any], None]: ...
    def imagej_metadata(self) -> Union[dict[str, Any], None]: ...
    def fluoview_metadata(self) -> Union[dict[str, Any], None]: ...
    @property
    def nih_metadata(self) -> Union[dict[str, Any], None]: ...
    @property
    def fei_metadata(self) -> Union[dict[str, Any], None]: ...
    @property
    def sem_metadata(self) -> Union[dict[str, Any], None]: ...
    @property
    def sis_metadata(self) -> Union[dict[str, Any], None]: ...
    def mdgel_metadata(self) -> Union[dict[str, Any], None]: ...
    @property
    def andor_metadata(self) -> Union[dict[str, Any], None]: ...
    @property
    def epics_metadata(self) -> Union[dict[str, Any], None]: ...
    @property
    def tvips_metadata(self) -> Union[dict[str, Any], None]: ...
    def metaseries_metadata(self) -> Union[dict[str, Any], None]: ...
    def pilatus_metadata(self) -> Union[dict[str, Any], None]: ...
    def micromanager_metadata(self) -> Union[dict[str, Any], None]: ...
    def scanimage_metadata(self) -> Union[dict[str, Any], None]: ...
    @property
    def geotiff_metadata(self) -> Union[dict[str, Any], None]: ...
    @property
    def gdal_metadata(self) -> Union[dict[str, Any], None]: ...
    def astrotiff_metadata(self) -> Union[dict[str, Any], None]: ...
    def streak_metadata(self) -> Union[dict[str, Any], None]: ...
    @property
    def eer_metadata(self) -> Union[str, None]: ...

class TiffFormat:
    version: int
    byteorder: Literal['>', '<']
    offsetsize: int
    offsetformat: str
    tagnosize: int
    tagnoformat: str
    tagsize: int
    tagformat1: str
    tagformat2: str
    tagoffsetthreshold: int
    def __init__(self, version: int, byteorder: Literal['>', '<'], offsetsize: int, offsetformat: str, tagnosize: int, tagnoformat: str, tagsize: int, tagformat1: str, tagformat2: str, tagoffsetthreshold: int) -> None: ...
    @property
    def is_bigtiff(self) -> bool: ...
    @property
    def is_ndpi(self) -> bool: ...
    def __hash__(self) -> int: ...

class TiffPages:
    parent: Union[TiffFile, None]
    pages: list[Union[TiffPage, TiffFrame, int]]
    def __init__(self, arg: Union[TiffFile, TiffPage, TiffFrame], *, index: Union[Sequence[int], int, None] = ...) -> None: ...
    @property
    def first(self) -> TiffPage: ...
    @property
    def is_multipage(self): ...
    @property
    def cache(self) -> bool: ...
    @cache.setter
    def cache(self, value: bool) -> None: ...
    @property
    def useframes(self) -> bool: ...
    @useframes.setter
    def useframes(self, value: bool) -> None: ...
    @property
    def keyframe(self) -> Union[TiffPage, None]: ...
    def set_keyframe(self, index: int) -> None: ...
    @property
    def next_page_offset(self) -> Union[int, None]: ...
    def get(self, key: int, default: Union[TiffPage, TiffFrame, None] = ..., *, validate: int = ..., cache: bool = ..., aspage: bool = ...) -> Union[TiffPage, TiffFrame]: ...
    @overload
    def __getitem__(self, key: int) -> Union[TiffPage, TiffFrame]: ...
    @overload
    def __getitem__(self, key: Union[slice, Iterable[int]]) -> list[Union[TiffPage, TiffFrame]]: ...
    def __iter__(self) -> Iterator[Union[TiffPage, TiffFrame]]: ...
    def __bool__(self) -> bool: ...
    def __len__(self) -> int: ...

class TiffPage:
    tags: TiffTags
    parent: TiffFile
    offset: int
    shape: tuple[int, ...]
    dtype: Union[numpy.dtype, None]
    shaped: tuple[int, int, int, int, int]
    axes: str
    dataoffsets: tuple[int, ...]
    databytecounts: tuple[int, ...]
    subfiletype: int
    imagewidth: int
    imagelength: int
    imagedepth: int
    tilewidth: int
    tilelength: int
    tiledepth: int
    samplesperpixel: int
    bitspersample: int
    sampleformat: int
    rowsperstrip: int
    compression: int
    planarconfig: int
    fillorder: int
    photometric: int
    predictor: int
    extrasamples: tuple[int, ...]
    subsampling: Union[tuple[int, int], None]
    subifds: Union[tuple[int, ...], None]
    jpegtables: Union[bytes, None]
    jpegheader: Union[bytes, None]
    software: str
    description: str
    description1: str
    nodata: Union[int, float]
    def __init__(self, parent: TiffFile, index: Union[int, Sequence[int]], *, keyframe: Union[TiffPage, None] = ...) -> None: ...
    def decode(self) -> Callable[..., tuple[Union[numpy.ndarray, None], tuple[int, int, int, int, int], tuple[int, int, int, int]]]: ...
    def segments(self, *, lock: Union[threading.RLock, NullContext, None] = ..., maxworkers: Union[int, None] = ..., func: Union[Callable[..., Any], None] = ..., sort: bool = ..., _fullsize: Union[bool, None] = ...) -> Iterator[tuple[Union[numpy.ndarray, None], tuple[int, int, int, int, int], tuple[int, int, int, int]]]: ...
    def asarray(self, *, out: Union[OutputType, None] = ..., squeeze: bool = ..., lock: Union[threading.RLock, NullContext, None] = ..., maxworkers: Union[int, None] = ...) -> numpy.ndarray: ...
    def aszarr(self, **kwargs) -> ZarrTiffStore: ...
    def asrgb(self, *, uint8: bool = ..., alpha: Union[Container[int], None] = ..., **kwargs) -> numpy.ndarray: ...
    def aspage(self) -> TiffPage: ...
    @property
    def index(self) -> int: ...
    @property
    def treeindex(self) -> tuple[int, ...]: ...
    @property
    def keyframe(self) -> TiffPage: ...
    @keyframe.setter
    def keyframe(self, index: TiffPage) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def ndim(self) -> int: ...
    def dims(self) -> tuple[str, ...]: ...
    def sizes(self) -> dict[str, int]: ...
    def coords(self) -> dict[str, numpy.ndarray]: ...
    def attr(self) -> dict[str, Any]: ...
    def size(self) -> int: ...
    def nbytes(self) -> int: ...
    @property
    def colormap(self) -> Union[numpy.ndarray, None]: ...
    @property
    def transferfunction(self) -> Union[numpy.ndarray, None]: ...
    def get_resolution(self, unit: Union[RESUNIT, int, str, None] = ..., scale: Union[float, int, None] = ...) -> tuple[Union[int, float], Union[int, float]]: ...
    def resolution(self) -> tuple[float, float]: ...
    @property
    def resolutionunit(self) -> int: ...
    @property
    def datetime(self) -> Union[datetime.datetime, None]: ...
    @property
    def tile(self) -> Union[tuple[int, ...], None]: ...
    def chunks(self) -> tuple[int, ...]: ...
    def chunked(self) -> tuple[int, ...]: ...
    def hash(self) -> int: ...
    def pages(self) -> Union[TiffPages, None]: ...
    def maxworkers(self) -> int: ...
    def is_contiguous(self) -> bool: ...
    def is_final(self) -> bool: ...
    def is_memmappable(self) -> bool: ...
    def flags(self) -> set[str]: ...
    def andor_tags(self) -> Union[dict[str, Any], None]: ...
    def epics_tags(self) -> Union[dict[str, Any], None]: ...
    def ndpi_tags(self) -> Union[dict[str, Any], None]: ...
    def geotiff_tags(self) -> Union[dict[str, Any], None]: ...
    def shaped_description(self) -> Union[str, None]: ...
    def imagej_description(self) -> Union[str, None]: ...
    def is_jfif(self) -> bool: ...
    @property
    def is_subifd(self) -> bool: ...
    @property
    def is_reduced(self) -> bool: ...
    @property
    def is_multipage(self) -> bool: ...
    @property
    def is_mask(self) -> bool: ...
    @property
    def is_mrc(self) -> bool: ...
    @property
    def is_tiled(self) -> bool: ...
    @property
    def is_subsampled(self) -> bool: ...
    @property
    def is_imagej(self) -> bool: ...
    @property
    def is_shaped(self) -> bool: ...
    @property
    def is_mdgel(self) -> bool: ...
    @property
    def is_mediacy(self) -> bool: ...
    @property
    def is_stk(self) -> bool: ...
    @property
    def is_lsm(self) -> bool: ...
    @property
    def is_fluoview(self) -> bool: ...
    @property
    def is_nih(self) -> bool: ...
    @property
    def is_volumetric(self) -> bool: ...
    @property
    def is_vista(self) -> bool: ...
    @property
    def is_metaseries(self) -> bool: ...
    @property
    def is_ome(self) -> bool: ...
    @property
    def is_scn(self) -> bool: ...
    @property
    def is_micromanager(self) -> bool: ...
    @property
    def is_andor(self) -> bool: ...
    @property
    def is_pilatus(self) -> bool: ...
    @property
    def is_epics(self) -> bool: ...
    @property
    def is_tvips(self) -> bool: ...
    @property
    def is_fei(self) -> bool: ...
    @property
    def is_sem(self) -> bool: ...
    @property
    def is_svs(self) -> bool: ...
    @property
    def is_bif(self) -> bool: ...
    @property
    def is_scanimage(self) -> bool: ...
    @property
    def is_qpi(self) -> bool: ...
    @property
    def is_geotiff(self) -> bool: ...
    @property
    def is_gdal(self) -> bool: ...
    @property
    def is_astrotiff(self) -> bool: ...
    @property
    def is_streak(self) -> bool: ...
    @property
    def is_tiffep(self) -> bool: ...
    @property
    def is_sis(self) -> bool: ...
    @property
    def is_ndpi(self) -> bool: ...
    @property
    def is_philips(self) -> bool: ...
    @property
    def is_eer(self) -> bool: ...

class TiffFrame:
    is_mdgel: bool
    pages: Incomplete
    parent: TiffFile
    offset: int
    dataoffsets: tuple[int, ...]
    databytecounts: tuple[int, ...]
    subifds: Union[tuple[int, ...], None]
    jpegtables: Union[bytes, None]
    def __init__(self, parent: TiffFile, index: Union[int, Sequence[int]], *, offset: Union[int, None] = ..., keyframe: Union[TiffPage, None] = ..., offsets: Union[tuple[int, ...], None] = ..., bytecounts: Union[tuple[int, ...], None] = ...) -> None: ...
    def aspage(self) -> TiffPage: ...
    def asarray(self, *args, **kwargs) -> numpy.ndarray: ...
    def aszarr(self, **kwargs) -> ZarrTiffStore: ...
    def asrgb(self, *args, **kwargs) -> numpy.ndarray: ...
    def segments(self, *args, **kwargs) -> Iterator[tuple[Union[numpy.ndarray, None], tuple[int, int, int, int, int], tuple[int, int, int, int]]]: ...
    @property
    def index(self) -> int: ...
    @property
    def treeindex(self) -> tuple[int, ...]: ...
    @property
    def keyframe(self) -> Union[TiffPage, None]: ...
    @keyframe.setter
    def keyframe(self, keyframe: TiffPage) -> None: ...
    @property
    def is_subifd(self) -> bool: ...
    @property
    def is_final(self) -> bool: ...
    @property
    def is_contiguous(self) -> bool: ...
    @property
    def is_memmappable(self) -> bool: ...
    @property
    def hash(self) -> int: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @property
    def shaped(self) -> tuple[int, int, int, int, int]: ...
    @property
    def chunks(self) -> tuple[int, ...]: ...
    @property
    def chunked(self) -> tuple[int, ...]: ...
    @property
    def tile(self) -> Union[tuple[int, ...], None]: ...
    @property
    def name(self) -> str: ...
    @property
    def ndim(self) -> int: ...
    @property
    def dims(self) -> tuple[str, ...]: ...
    @property
    def sizes(self) -> dict[str, int]: ...
    @property
    def coords(self) -> dict[str, numpy.ndarray]: ...
    @property
    def size(self) -> int: ...
    @property
    def nbytes(self) -> int: ...
    @property
    def dtype(self) -> Union[numpy.dtype, None]: ...
    @property
    def axes(self) -> str: ...
    def get_resolution(self, unit: Union[RESUNIT, int, None] = ..., scale: Union[float, int, None] = ...) -> tuple[Union[int, float], Union[int, float]]: ...
    @property
    def resolution(self) -> tuple[float, float]: ...
    @property
    def resolutionunit(self) -> int: ...
    @property
    def datetime(self) -> Union[datetime.datetime, None]: ...
    @property
    def compression(self) -> int: ...
    @property
    def decode(self): ...

class TiffTag:
    parent: Union[TiffFile, TiffWriter]
    offset: int
    code: int
    dtype: int
    count: int
    valueoffset: int
    def __init__(self, parent: Union[TiffFile, TiffWriter], offset: int, code: int, dtype: Union[DATATYPE, int], count: int, value: Any, valueoffset: int) -> None: ...
    @classmethod
    def fromfile(cls, parent: TiffFile, *, offset: Union[int, None] = ..., header: Union[bytes, None] = ..., validate: bool = ...) -> TiffTag: ...
    @property
    def value(self) -> Any: ...
    @value.setter
    def value(self, value: Any) -> None: ...
    @property
    def dtype_name(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def dataformat(self) -> str: ...
    @property
    def valuebytecount(self) -> int: ...
    def astuple(self) -> tuple[int, int, int, bytes]: ...
    def overwrite(self, value: Any, *, dtype: Union[DATATYPE, int, str, None] = ..., erase: bool = ...) -> TiffTag: ...

class TiffTags:
    def __init__(self) -> None: ...
    def add(self, tag: TiffTag) -> None: ...
    def keys(self) -> list[int]: ...
    def values(self) -> list[TiffTag]: ...
    def items(self) -> list[tuple[int, TiffTag]]: ...
    def valueof(self, key: Union[int, str], default: Any = ..., index: Union[int, None] = ...) -> Any: ...
    def get(self, key: Union[int, str], default: Union[TiffTag, None] = ..., index: Union[int, None] = ...) -> Union[TiffTag, None]: ...
    def getall(self, key: Union[int, str], default: Incomplete | None = ...) -> Union[list[TiffTag], None]: ...
    def __getitem__(self, key: Union[int, str]) -> TiffTag: ...
    def __setitem__(self, code: int, tag: TiffTag) -> None: ...
    def __delitem__(self, key: Union[int, str]) -> None: ...
    def __contains__(self, item: object) -> bool: ...
    def __iter__(self) -> Iterator[TiffTag]: ...
    def __len__(self) -> int: ...

class TiffTagRegistry:
    def __init__(self, arg: Union[TiffTagRegistry, dict[int, str], Sequence[tuple[int, str]]]) -> None: ...
    def update(self, arg: Union[TiffTagRegistry, dict[int, str], Sequence[tuple[int, str]]]): ...
    def add(self, code: int, name: str) -> None: ...
    def items(self) -> list[tuple[int, str]]: ...
    @overload
    def get(self, key: int, default: None) -> Union[str, None]: ...
    @overload
    def get(self, key: str, default: None) -> Union[int, None]: ...
    @overload
    def get(self, key: int, default: str) -> str: ...
    @overload
    def getall(self, key: int, default: None) -> Union[list[str], None]: ...
    @overload
    def getall(self, key: str, default: None) -> Union[list[int], None]: ...
    @overload
    def getall(self, key: int, default: list[str]) -> list[str]: ...
    @overload
    def __getitem__(self, key: int) -> str: ...
    @overload
    def __getitem__(self, key: str) -> int: ...
    def __delitem__(self, key: Union[int, str]) -> None: ...
    def __contains__(self, item: Union[int, str]) -> bool: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...

class TiffPageSeries:
    levels: list[TiffPageSeries]
    parent: Union[TiffFile, None]
    keyframe: TiffPage
    dtype: numpy.dtype
    kind: str
    name: str
    index: int
    transform: Union[Callable[[numpy.ndarray], numpy.ndarray], None]
    is_multifile: bool
    def __init__(self, pages: Sequence[Union[TiffPage, TiffFrame, None]], shape: Union[Sequence[int], None] = ..., dtype: Union[numpy.dtype, str, None] = ..., axes: Union[str, None] = ..., *, attr: Union[dict[str, Any], None] = ..., coords: Union[Mapping[str, Union[numpy.ndarray, None]], None] = ..., index: Union[int, None] = ..., parent: Union[TiffFile, None] = ..., name: Union[str, None] = ..., kind: Union[str, None] = ..., truncated: bool = ..., multifile: bool = ..., squeeze: bool = ..., transform: Union[Callable[[numpy.ndarray], numpy.ndarray], None] = ...) -> None: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @property
    def axes(self) -> str: ...
    @property
    def coords(self) -> dict[str, numpy.ndarray]: ...
    def get_shape(self, squeeze: Union[bool, None] = ...) -> tuple[int, ...]: ...
    def get_axes(self, squeeze: Union[bool, None] = ...) -> str: ...
    def get_coords(self, squeeze: Union[bool, None] = ...) -> dict[str, numpy.ndarray]: ...
    def asarray(self, *, level: Union[int, None] = ..., **kwargs) -> numpy.ndarray: ...
    def aszarr(self, *, level: Union[int, None] = ..., **kwargs) -> ZarrTiffStore: ...
    def dataoffset(self) -> Union[int, None]: ...
    @property
    def offset(self) -> Union[int, None]: ...
    @property
    def is_pyramidal(self) -> bool: ...
    def attr(self) -> dict[str, Any]: ...
    @property
    def ndim(self) -> int: ...
    @property
    def dims(self) -> tuple[str, ...]: ...
    @property
    def sizes(self) -> dict[str, int]: ...
    def size(self) -> int: ...
    def nbytes(self) -> int: ...
    @property
    def pages(self) -> TiffPageSeries: ...
    @overload
    def __getitem__(self, key: Union[int, numpy.integer]) -> Union[TiffPage, TiffFrame, None]: ...
    @overload
    def __getitem__(self, key: Union[slice, Iterable[int]]) -> list[Union[TiffPage, TiffFrame, None]]: ...
    def __iter__(self) -> Iterator[Union[TiffPage, TiffFrame, None]]: ...
    def __len__(self) -> int: ...

class ZarrStore(collections.abc.MutableMapping):
    def __init__(self, *, fillvalue: Union[int, float, None] = ..., chunkmode: Union[CHUNKMODE, int, str, None] = ...) -> None: ...
    def __enter__(self) -> ZarrStore: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def clear(self) -> None: ...
    def keys(self) -> KeysView[str]: ...
    def items(self) -> ItemsView[str, Any]: ...
    def values(self) -> ValuesView[Any]: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def __contains__(self, key) -> bool: ...
    def __delitem__(self, key) -> None: ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value) -> None: ...
    @property
    def is_multiscales(self) -> bool: ...

class ZarrTiffStore(ZarrStore):
    def __init__(self, arg: Union[TiffPage, TiffFrame, TiffPageSeries], *, level: Union[int, None] = ..., chunkmode: Union[CHUNKMODE, int, str, None] = ..., fillvalue: Union[int, float, None] = ..., zattrs: Union[dict[str, Any], None] = ..., multiscales: Union[bool, None] = ..., lock: Union[threading.RLock, NullContext, None] = ..., squeeze: Union[bool, None] = ..., maxworkers: Union[int, None] = ..., _openfiles: Union[int, None] = ...) -> None: ...
    def close(self) -> None: ...
    def write_fsspec(self, jsonfile: Union[str, os.PathLike, TextIO], url: str, *, groupname: Union[str, None] = ..., templatename: Union[str, None] = ..., compressors: dict[Union[COMPRESSION, int], Union[str, None]] = ..., version: Union[int, None] = ..., _shape: Union[Sequence[int], None] = ..., _axes: Union[Sequence[str], None] = ..., _index: Union[Sequence[int], None] = ..., _append: bool = ..., _close: bool = ...) -> None: ...
    def __enter__(self) -> ZarrTiffStore: ...

class ZarrFileSequenceStore(ZarrStore):
    imread: Callable[..., numpy.ndarray]
    def __init__(self, arg: FileSequence, *, fillvalue: Union[int, float, None] = ..., chunkmode: Union[CHUNKMODE, int, str, None] = ..., chunkshape: Union[Sequence[int], None] = ..., dtype: Union[numpy.dtype, str, None] = ..., axestiled: Union[dict[int, int], Sequence[tuple[int, int]], None] = ..., zattrs: Union[dict[str, Any], None] = ..., **kwargs) -> None: ...
    def write_fsspec(self, jsonfile: Union[str, os.PathLike, TextIO], url: str, *, groupname: Union[str, None] = ..., templatename: Union[str, None] = ..., codec_id: Union[str, None] = ..., version: Union[int, None] = ..., _append: bool = ..., _close: bool = ...) -> None: ...
    def __enter__(self) -> ZarrFileSequenceStore: ...

class FileSequence:
    imread: Callable[..., numpy.ndarray]
    files: list[str]
    shape: tuple[int, ...]
    axes: str
    dims: tuple[str, ...]
    indices: tuple[tuple[int, ...]]
    def __init__(self, imread: Callable[..., numpy.ndarray], files: Union[str, os.PathLike, Sequence[Union[str, os.PathLike]], None], *, container: Union[str, os.PathLike, None] = ..., sort: Union[Callable[..., Any], bool, None] = ..., parse: Union[Callable[..., Any], None] = ..., **kwargs) -> None: ...
    def asarray(self, *, axestiled: Union[dict[int, int], Sequence[tuple[int, int]], None] = ..., ioworkers: int = ..., out: OutputType = ..., **kwargs) -> numpy.ndarray: ...
    def aszarr(self, **kwargs) -> ZarrFileSequenceStore: ...
    def close(self) -> None: ...
    def commonpath(self) -> str: ...
    @property
    def labels(self) -> tuple[str, ...]: ...
    @property
    def files_missing(self) -> int: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, key: int) -> str: ...
    @overload
    def __getitem__(self, key: slice) -> list[str]: ...
    def __enter__(self) -> FileSequence: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...

class TiffSequence(FileSequence):
    def __init__(self, files: Union[str, os.PathLike, Sequence[Union[str, os.PathLike]], None] = ..., *, imread: Callable[..., numpy.ndarray] = ..., **kwargs) -> None: ...

class TiledSequence:
    shape: tuple[int, ...]
    chunks: tuple[int, ...]
    axes: Union[str, tuple[str, ...], None]
    def __init__(self, stackshape: Sequence[int], chunkshape: Sequence[int], axestiled: Union[dict[int, int], Sequence[tuple[int, int]], None] = ..., axes: Union[str, Sequence[str], None] = ...) -> None: ...
    def indices(self, indices: Iterable[Sequence[int]]) -> Iterator[tuple[int, ...]]: ...
    def slices(self, indices: Iterable[Sequence[int]]) -> Iterator[tuple[Union[int, slice], ...]]: ...
    @property
    def ndim(self) -> int: ...
    @property
    def is_tiled(self) -> bool: ...

class FileHandle:
    def __init__(self, file: Union[str, os.PathLike, FileHandle, BinaryIO], mode: Union[Literal['r', 'r+', 'w', 'rb', 'r+b', 'wb'], None] = ..., *, name: Union[str, None] = ..., offset: Union[int, None] = ..., size: Union[int, None] = ...) -> None: ...
    def open(self) -> None: ...
    def close(self) -> None: ...
    def writable(self) -> bool: ...
    def seekable(self) -> bool: ...
    def tell(self) -> int: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def read(self, size: int = ...) -> bytes: ...
    def readinto(self, buffer) -> int: ...
    def write(self, buffer: bytes) -> int: ...
    def flush(self) -> None: ...
    def memmap_array(self, dtype: Union[str, numpy.dtype], shape: tuple[int, ...], offset: int = ..., *, mode: str = ..., order: str = ...) -> numpy.ndarray: ...
    def read_array(self, dtype: Union[numpy.dtype, str], count: int = ..., *, out: Union[numpy.ndarray, None] = ...) -> numpy.ndarray: ...
    def read_record(self, dtype: Union[numpy.dtype, str], shape: Union[tuple[int, ...], int, None] = ..., *, byteorder: Union[Literal['S', '<', '>', '=', '|'], None] = ...) -> numpy.recarray: ...
    def write_empty(self, size: int) -> int: ...
    def write_array(self, data: numpy.ndarray) -> int: ...
    def read_segments(self, offsets: Sequence[int], bytecounts: Sequence[int], indices: Union[Sequence[int], None] = ..., *, sort: bool = ..., lock: Union[threading.RLock, NullContext, None] = ..., buffersize: Union[int, None] = ..., flat: bool = ...) -> Union[Iterator[tuple[Union[bytes, None], int]], Iterator[list[tuple[Union[bytes, None], int]]]]: ...
    def __enter__(self) -> FileHandle: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
    @property
    def name(self) -> str: ...
    @property
    def dirname(self) -> str: ...
    @property
    def path(self) -> str: ...
    @property
    def extension(self) -> str: ...
    @property
    def size(self) -> int: ...
    @property
    def closed(self): ...
    @property
    def lock(self) -> Union[threading.RLock, NullContext]: ...
    @lock.setter
    def lock(self, value: bool) -> None: ...
    def set_lock(self, value: bool) -> None: ...
    @property
    def has_lock(self) -> bool: ...
    @property
    def is_file(self) -> bool: ...

class FileCache:
    size: int
    files: dict[FileHandle, int]
    keep: set[FileHandle]
    past: list[FileHandle]
    lock: Union[threading.RLock, NullContext]
    def __init__(self, size: Union[int, None] = ..., *, lock: Union[threading.RLock, NullContext, None] = ...) -> None: ...
    def open(self, fh: FileHandle) -> None: ...
    def close(self, fh: FileHandle) -> None: ...
    def clear(self) -> None: ...
    def read(self, fh: FileHandle, offset: int, bytecount: int, whence: int = ...) -> bytes: ...
    def write(self, fh: FileHandle, offset: int, data: bytes, whence: int = ...) -> int: ...
    def __len__(self) -> int: ...

class StoredShape:
    frames: int
    separate_samples: int
    depth: int
    length: int
    width: int
    contig_samples: int
    extrasamples: int
    def __init__(self, frames: int = ..., separate_samples: int = ..., depth: int = ..., length: int = ..., width: int = ..., contig_samples: int = ..., extrasamples: int = ...) -> None: ...
    @property
    def size(self) -> int: ...
    @property
    def samples(self) -> int: ...
    @property
    def photometric_samples(self) -> int: ...
    @property
    def shape(self) -> tuple[int, int, int, int, int, int]: ...
    @property
    def page_shape(self) -> tuple[int, int, int, int, int]: ...
    @property
    def page_size(self) -> int: ...
    @property
    def squeezed(self) -> tuple[int, ...]: ...
    @property
    def is_valid(self) -> bool: ...
    @property
    def is_planar(self) -> bool: ...
    @property
    def planarconfig(self) -> Union[int, None]: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, key: int) -> int: ...
    @overload
    def __getitem__(self, key: slice) -> tuple[int, ...]: ...
    def __eq__(self, other) -> bool: ...

class NullContext:
    def __enter__(self) -> NullContext: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...

class Timer:
    started: float
    stopped: float
    duration: float
    def __init__(self, message: Union[str, None] = ..., *, end: str = ..., started: Union[float, None] = ...) -> None: ...
    def start(self, message: Union[str, None] = ..., *, end: str = ...) -> float: ...
    def stop(self, message: Union[str, None] = ..., *, end: str = ...) -> float: ...
    def print(self, message: Union[str, None] = ..., *, end: Union[str, None] = ...) -> None: ...
    @staticmethod
    def clock() -> float: ...
    def __enter__(self) -> Timer: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...

class OmeXmlError(Exception): ...

class OmeXml:
    images: list[str]
    annotations: list[str]
    elements: list[str]
    def __init__(self, **metadata) -> None: ...
    def addimage(self, dtype: Union[numpy.dtype, str], shape: Sequence[int], storedshape: tuple[int, int, int, int, int, int], *, axes: Union[str, None] = ..., **metadata) -> None: ...
    def tostring(self, *, declaration: bool = ...) -> str: ...
    @staticmethod
    def validate(omexml: str, omexsd: Union[bytes, None] = ..., assert_: bool = ..., *, _schema: list[Any] = ...) -> Union[bool, None]: ...

class CompressionCodec(collections.abc.Mapping):
    def __init__(self, encode: bool) -> None: ...
    def __getitem__(self, key: int) -> Callable[..., Any]: ...
    def __contains__(self, key) -> bool: ...
    def __iter__(self) -> Iterator[Callable[..., Any]]: ...
    def __len__(self) -> int: ...

class PredictorCodec(collections.abc.Mapping):
    def __init__(self, encode: bool) -> None: ...
    def __getitem__(self, key: int) -> Callable[..., Any]: ...
    def __contains__(self, key) -> bool: ...
    def __iter__(self) -> Iterator[Callable[..., Any]]: ...
    def __len__(self) -> int: ...

class DATATYPE(enum.IntEnum):
    BYTE: int
    ASCII: int
    SHORT: int
    LONG: int
    RATIONAL: int
    SBYTE: int
    UNDEFINED: int
    SSHORT: int
    SLONG: int
    SRATIONAL: int
    FLOAT: int
    DOUBLE: int
    IFD: int
    UNICODE: int
    COMPLEX: int
    LONG8: int
    SLONG8: int
    IFD8: int

class COMPRESSION(enum.IntEnum):
    NONE: int
    CCITTRLE: int
    CCITT_T4: int
    CCITT_T6: int
    LZW: int
    OJPEG: int
    JPEG: int
    ADOBE_DEFLATE: int
    JBIG_BW: int
    JBIG_COLOR: int
    JPEG_99: int
    KODAK_262: int
    JPEGXR_NDPI: int
    NEXT: int
    SONY_ARW: int
    PACKED_RAW: int
    SAMSUNG_SRW: int
    CCIRLEW: int
    SAMSUNG_SRW2: int
    PACKBITS: int
    THUNDERSCAN: int
    IT8CTPAD: int
    IT8LW: int
    IT8MP: int
    IT8BL: int
    PIXARFILM: int
    PIXARLOG: int
    DEFLATE: int
    DCS: int
    APERIO_JP2000_YCBC: int
    JPEG_2000_LOSSY: int
    APERIO_JP2000_RGB: int
    ALT_JPEG: int
    JBIG: int
    SGILOG: int
    SGILOG24: int
    JPEG2000: int
    NIKON_NEF: int
    JBIG2: int
    MDI_BINARY: int
    MDI_PROGRESSIVE: int
    MDI_VECTOR: int
    LERC: int
    JPEG_LOSSY: int
    LZMA: int
    ZSTD_DEPRECATED: int
    WEBP_DEPRECATED: int
    PNG: int
    JPEGXR: int
    JETRAW: int
    ZSTD: int
    WEBP: int
    JPEGXL: int
    PIXTIFF: int
    def __bool__(self) -> bool: ...

class PREDICTOR(enum.IntEnum):
    NONE: int
    HORIZONTAL: int
    FLOATINGPOINT: int
    HORIZONTALX2: int
    HORIZONTALX4: int
    FLOATINGPOINTX2: int
    FLOATINGPOINTX4: int
    def __bool__(self) -> bool: ...

class PHOTOMETRIC(enum.IntEnum):
    MINISWHITE: int
    MINISBLACK: int
    RGB: int
    PALETTE: int
    MASK: int
    SEPARATED: int
    YCBCR: int
    CIELAB: int
    ICCLAB: int
    ITULAB: int
    CFA: int
    LOGL: int
    LOGLUV: int
    LINEAR_RAW: int
    DEPTH_MAP: int
    SEMANTIC_MASK: int

class FILETYPE(enum.IntFlag):
    UNDEFINED: int
    REDUCEDIMAGE: int
    PAGE: int
    MASK: int
    MACRO: int
    ENHANCED: int
    DNG: int

class OFILETYPE(enum.IntEnum):
    UNDEFINED: int
    IMAGE: int
    REDUCEDIMAGE: int
    PAGE: int

class FILLORDER(enum.IntEnum):
    MSB2LSB: int
    LSB2MSB: int

class ORIENTATION(enum.IntEnum):
    TOPLEFT: int
    TOPRIGHT: int
    BOTRIGHT: int
    BOTLEFT: int
    LEFTTOP: int
    RIGHTTOP: int
    RIGHTBOT: int
    LEFTBOT: int

class PLANARCONFIG(enum.IntEnum):
    CONTIG: int
    SEPARATE: int

class RESUNIT(enum.IntEnum):
    NONE: int
    INCH: int
    CENTIMETER: int
    MILLIMETER: int
    MICROMETER: int
    def __bool__(self) -> bool: ...

class EXTRASAMPLE(enum.IntEnum):
    UNSPECIFIED: int
    ASSOCALPHA: int
    UNASSALPHA: int

class SAMPLEFORMAT(enum.IntEnum):
    UINT: int
    INT: int
    IEEEFP: int
    VOID: int
    COMPLEXINT: int
    COMPLEXIEEEFP: int

class CHUNKMODE(enum.IntEnum):
    STRILE: int
    PLANE: int
    PAGE: int
    FILE: int

class _TIFF:
    def CLASSIC_LE(self) -> TiffFormat: ...
    def CLASSIC_BE(self) -> TiffFormat: ...
    def BIG_LE(self) -> TiffFormat: ...
    def BIG_BE(self) -> TiffFormat: ...
    def NDPI_LE(self) -> TiffFormat: ...
    def TAGS(self) -> TiffTagRegistry: ...
    def TAG_READERS(self) -> dict[int, Callable[[FileHandle, ByteOrder, int, int, int], Any]]: ...
    def TAG_LOAD(self) -> frozenset[int]: ...
    def TAG_TUPLE(self) -> frozenset[int]: ...
    def TAG_ATTRIBUTES(self) -> dict[int, str]: ...
    def TAG_ENUM(self) -> dict[int, type[enum.Enum]]: ...
    def EXIF_TAGS(self) -> TiffTagRegistry: ...
    def NDPI_TAGS(self) -> TiffTagRegistry: ...
    def GPS_TAGS(self) -> TiffTagRegistry: ...
    def IOP_TAGS(self) -> TiffTagRegistry: ...
    def PHOTOMETRIC_SAMPLES(self) -> dict[int, int]: ...
    def DATA_FORMATS(self) -> dict[int, str]: ...
    def DATA_DTYPES(self) -> dict[str, int]: ...
    def SAMPLE_DTYPES(self) -> dict[tuple[int, Union[int, tuple[int, ...]]], str]: ...
    def PREDICTORS(self) -> Mapping[int, Callable[..., Any]]: ...
    def UNPREDICTORS(self) -> Mapping[int, Callable[..., Any]]: ...
    def COMPRESSORS(self) -> Mapping[int, Callable[..., Any]]: ...
    def DECOMPRESSORS(self) -> Mapping[int, Callable[..., Any]]: ...
    def IMAGE_COMPRESSIONS(self) -> set[int]: ...
    def AXES_NAMES(self) -> dict[str, str]: ...
    def AXES_CODES(self) -> dict[str, str]: ...
    def AXES_LABELS(self) -> dict[str, str]: ...
    def GEO_KEYS(self) -> type[enum.IntEnum]: ...
    def GEO_CODES(self) -> dict[int, type[enum.IntEnum]]: ...
    def PAGE_FLAGS(self) -> set[str]: ...
    def FILE_FLAGS(self) -> set[str]: ...
    @property
    def FILE_PATTERNS(self) -> dict[str, str]: ...
    @property
    def FILE_EXTENSIONS(self) -> tuple[str, ...]: ...
    @property
    def FILEOPEN_FILTER(self) -> list[tuple[str, str]]: ...
    @property
    def CZ_LSMINFO(self) -> list[tuple[str, str]]: ...
    @property
    def CZ_LSMINFO_READERS(self) -> dict[str, Union[Callable[[FileHandle], Any], None]]: ...
    @property
    def CZ_LSMINFO_SCANTYPE(self) -> dict[int, str]: ...
    @property
    def CZ_LSMINFO_DIMENSIONS(self) -> dict[str, str]: ...
    @property
    def CZ_LSMINFO_DATATYPES(self) -> dict[int, str]: ...
    @property
    def CZ_LSMINFO_TYPEOFDATA(self) -> dict[int, str]: ...
    @property
    def CZ_LSMINFO_SCANINFO_ARRAYS(self) -> dict[int, str]: ...
    @property
    def CZ_LSMINFO_SCANINFO_STRUCTS(self) -> dict[int, str]: ...
    @property
    def CZ_LSMINFO_SCANINFO_ATTRIBUTES(self) -> dict[int, str]: ...
    def CZ_LSM_LUTTYPE(self): ...
    def CZ_LSM_SUBBLOCK_TYPE(self): ...
    @property
    def NIH_IMAGE_HEADER(self): ...
    @property
    def NIH_COLORTABLE_TYPE(self) -> tuple[str, ...]: ...
    @property
    def NIH_LUTMODE_TYPE(self) -> tuple[str, ...]: ...
    @property
    def NIH_CURVEFIT_TYPE(self) -> tuple[str, ...]: ...
    @property
    def NIH_UNITS_TYPE(self) -> tuple[str, ...]: ...
    @property
    def TVIPS_HEADER_V1(self) -> list[tuple[str, str]]: ...
    @property
    def TVIPS_HEADER_V2(self) -> list[tuple[str, str]]: ...
    @property
    def MM_HEADER(self) -> list[tuple[Any, ...]]: ...
    @property
    def MM_DIMENSIONS(self) -> dict[str, str]: ...
    @property
    def UIC_TAGS(self) -> list[tuple[str, Any]]: ...
    @property
    def PILATUS_HEADER(self) -> dict[str, Any]: ...
    def ALLOCATIONGRANULARITY(self) -> int: ...
    def MAXWORKERS(self) -> int: ...
    BUFFERSIZE: int
    def CHUNKMODE(self) -> type[CHUNKMODE]: ...
    def COMPRESSION(self) -> type[COMPRESSION]: ...
    def PREDICTOR(self) -> type[PREDICTOR]: ...
    def EXTRASAMPLE(self) -> type[EXTRASAMPLE]: ...
    def FILETYPE(self) -> type[FILETYPE]: ...
    def FILLORDER(self) -> type[FILLORDER]: ...
    def PHOTOMETRIC(self) -> type[PHOTOMETRIC]: ...
    def PLANARCONFIG(self) -> type[PLANARCONFIG]: ...
    def RESUNIT(self) -> type[RESUNIT]: ...
    def ORIENTATION(self) -> type[ORIENTATION]: ...
    def SAMPLEFORMAT(self) -> type[SAMPLEFORMAT]: ...
    def DATATYPES(self) -> type[DATATYPE]: ...

TIFF: Incomplete

def read_scanimage_metadata(fh: FileHandle) -> tuple[dict[str, Any], dict[str, Any], int]: ...
def read_micromanager_metadata(fh: Union[FileHandle, BinaryIO]) -> dict[str, Any]: ...
def imagej_metadata_tag(metadata: dict[str, Any], byteorder: ByteOrder) -> tuple[tuple[int, int, int, bytes, bool], tuple[int, int, int, bytes, bool]]: ...
def imagej_description(shape: Sequence[int], axes: Union[str, None] = ..., rgb: Union[bool, None] = ..., colormaped: bool = ..., **metadata) -> str: ...
def parse_filenames(files: Sequence[str], pattern: str, axesorder: Union[Sequence[int], None] = ..., categories: Union[dict[str, dict[str, int]], None] = ..., *, _shape: Union[Sequence[int], None] = ...) -> tuple[tuple[str, ...], tuple[int, ...], list[tuple[int, ...]], Sequence[str]]: ...
def repeat_nd(a: ArrayLike, repeats: Sequence[int]) -> numpy.ndarray: ...
@overload
def reshape_nd(data_or_shape: tuple[int, ...], ndim: int) -> tuple[int, ...]: ...
@overload
def reshape_nd(data_or_shape: numpy.ndarray, ndim: int) -> numpy.ndarray: ...
def squeeze_axes(shape: Sequence[int], axes: str, skip: Union[str, None] = ...) -> tuple[tuple[int, ...], str]: ...
def transpose_axes(image: numpy.ndarray, axes: str, asaxes: Union[str, None] = ...) -> numpy.ndarray: ...
def reshape_axes(axes: str, shape: Sequence[int], newshape: Sequence[int], unknown: Union[str, None] = ...) -> str: ...
def create_output(out: OutputType, shape: Sequence[int], dtype: Union[numpy.dtype, str], *, mode: Literal['r+', 'w+', 'r', 'c'] = ..., suffix: Union[str, None] = ..., fillvalue: Union[int, float, None] = ...) -> Union[numpy.ndarray, numpy.memmap]: ...
def matlabstr2py(matlabstr: str) -> Any: ...
def strptime(datetime_string: str, format: Union[str, None] = ...) -> datetime.datetime: ...
@overload
def stripnull(string: bytes, null: Union[bytes, None] = ..., *, first: bool = ...) -> bytes: ...
@overload
def stripnull(string: str, null: Union[str, None] = ..., *, first: bool = ...) -> str: ...
def astype(value: Any, types: Union[Sequence[Any], None] = ...) -> Any: ...
def format_size(size: Union[int, float], threshold: Union[int, float] = ...) -> str: ...
def nullfunc(*args, **kwargs) -> None: ...
def product(iterable: Iterable[int]) -> int: ...
def natural_sorted(iterable: Iterable[str]) -> list[str]: ...
def xml2dict(xml: str, sanitize: bool = ..., prefix: Union[tuple[str, str], None] = ...) -> dict[str, Any]: ...
def hexdump(data: bytes, *, width: int = ..., height: int = ..., snipat: Union[int, float, None] = ..., modulo: int = ..., ellipsis: Union[str, None] = ...) -> str: ...
def pformat(arg: Any, *, width: Union[int, None] = ..., height: Union[int, None] = ..., compact: bool = ...) -> str: ...
def enumstr(enum) -> str: ...
def enumarg(enum: type[enum.IntEnum], arg: Any) -> enum.IntEnum: ...
def parse_kwargs(kwargs: dict[str, Any], *keys: str, **keyvalues) -> dict[str, Any]: ...
def update_kwargs(kwargs: dict[str, Any], **keyvalues) -> None: ...
def validate_jhove(filename: str, jhove: Union[str, None] = ..., ignore: Union[Collection[str], None] = ...) -> None: ...
def tiffcomment(arg: Union[str, os.PathLike, FileHandle, BinaryIO], comment: Union[str, bytes, None] = ..., pageindex: Union[int, None] = ..., tagcode: Union[int, str, None] = ...) -> Union[str, None]: ...
def tiff2fsspec(filename: Union[str, os.PathLike], url: str, *, out: Union[str, None] = ..., key: Union[int, None] = ..., series: Union[int, None] = ..., level: Union[int, None] = ..., chunkmode: Union[CHUNKMODE, int, str, None] = ..., fillvalue: Union[int, float, None] = ..., zattrs: Union[dict[str, Any], None] = ..., squeeze: Union[bool, None] = ..., maxworkers: Union[int, None] = ..., groupname: Union[str, None] = ..., version: Union[int, None] = ...) -> None: ...
def lsm2bin(lsmfile: str, binfile: Union[str, None] = ..., *, tile: Union[tuple[int, int], None] = ..., verbose: bool = ...) -> None: ...
def imshow(data: numpy.ndarray, *, photometric: Union[PHOTOMETRIC, int, str, None] = ..., planarconfig: Union[PLANARCONFIG, int, str, None] = ..., bitspersample: Union[int, None] = ..., nodata: Union[int, float] = ..., interpolation: Union[str, int, None] = ..., cmap: Union[Any, None] = ..., vmin: Union[int, float, None] = ..., vmax: Union[int, float, None] = ..., figure: Any = ..., subplot: Any = ..., title: Union[str, None] = ..., dpi: int = ..., maxdim: Union[int, None] = ..., background: Union[tuple[float, float, float], str, None] = ..., show: bool = ..., **kwargs) -> tuple[Any, Any, Any]: ...
def askopenfilename(**kwargs) -> str: ...
TiffReader = TiffFile

class lazyattr:
    func: Incomplete
    __doc__: Incomplete
    __module__: Incomplete
    __name__: Incomplete
    __qualname__: Incomplete
    def __init__(self, func) -> None: ...
    def __get__(self, instance, owner): ...

# Names in __all__ with no definition:
#   _app_show
