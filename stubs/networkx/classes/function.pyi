from _typeshed import Incomplete
from collections.abc import Generator
from networkx.classes.graphviews import reverse_view as reverse_view, subgraph_view as subgraph_view

def nodes(G): ...
def edges(G, nbunch: Incomplete | None = ...): ...
def degree(G, nbunch: Incomplete | None = ..., weight: Incomplete | None = ...): ...
def neighbors(G, n): ...
def number_of_nodes(G): ...
def number_of_edges(G): ...
def density(G): ...
def degree_histogram(G): ...
def is_directed(G): ...
def freeze(G): ...
def is_frozen(G): ...
def add_star(G_to_add_to, nodes_for_star, **attr) -> None: ...
def add_path(G_to_add_to, nodes_for_path, **attr) -> None: ...
def add_cycle(G_to_add_to, nodes_for_cycle, **attr) -> None: ...
def subgraph(G, nbunch): ...
def induced_subgraph(G, nbunch): ...
def edge_subgraph(G, edges): ...
def restricted_view(G, nodes, edges): ...
def to_directed(graph): ...
def to_undirected(graph): ...
def create_empty_copy(G, with_data: bool = ...): ...
def info(G, n: Incomplete | None = ...): ...
def set_node_attributes(G, values, name: Incomplete | None = ...) -> None: ...
def get_node_attributes(G, name): ...
def set_edge_attributes(G, values, name: Incomplete | None = ...) -> None: ...
def get_edge_attributes(G, name): ...
def all_neighbors(graph, node): ...
def non_neighbors(graph, node): ...
def non_edges(graph) -> Generator[Incomplete, None, None]: ...
def common_neighbors(G, u, v): ...
def is_weighted(G, edge: Incomplete | None = ..., weight: str = ...): ...
def is_negatively_weighted(G, edge: Incomplete | None = ..., weight: str = ...): ...
def is_empty(G): ...
def nodes_with_selfloops(G): ...
def selfloop_edges(G, data: bool = ..., keys: bool = ..., default: Incomplete | None = ...): ...
def number_of_selfloops(G): ...
def is_path(G, path): ...
def path_weight(G, path, weight): ...
