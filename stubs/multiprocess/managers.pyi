from _typeshed import Incomplete

class Token:
    def __init__(self, typeid, address, id) -> None: ...

class RemoteError(Exception): ...

class Server:
    public: Incomplete
    registry: Incomplete
    authkey: Incomplete
    listener: Incomplete
    address: Incomplete
    id_to_obj: Incomplete
    id_to_refcount: Incomplete
    id_to_local_proxy_obj: Incomplete
    mutex: Incomplete
    def __init__(self, registry, address, authkey, serializer) -> None: ...
    stop_event: Incomplete
    def serve_forever(self) -> None: ...
    def accepter(self) -> None: ...
    def handle_request(self, conn) -> None: ...
    def serve_client(self, conn) -> None: ...
    def fallback_getvalue(self, conn, ident, obj): ...
    def fallback_str(self, conn, ident, obj): ...
    def fallback_repr(self, conn, ident, obj): ...
    fallback_mapping: Incomplete
    def dummy(self, c) -> None: ...
    def debug_info(self, c): ...
    def number_of_objects(self, c): ...
    def shutdown(self, c) -> None: ...
    def create(self, c, typeid, *args, **kwds): ...
    def get_methods(self, c, token): ...
    def accept_connection(self, c, name) -> None: ...
    def incref(self, c, ident) -> None: ...
    def decref(self, c, ident) -> None: ...

class State:
    INITIAL: int
    STARTED: int
    SHUTDOWN: int

class BaseManager:
    def __init__(self, address: Incomplete | None = ..., authkey: Incomplete | None = ..., serializer: str = ..., ctx: Incomplete | None = ...) -> None: ...
    def get_server(self): ...
    def connect(self) -> None: ...
    shutdown: Incomplete
    def start(self, initializer: Incomplete | None = ..., initargs=...) -> None: ...
    def join(self, timeout: Incomplete | None = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
    @property
    def address(self): ...
    @classmethod
    def register(cls, typeid, callable: Incomplete | None = ..., proxytype: Incomplete | None = ..., exposed: Incomplete | None = ..., method_to_typeid: Incomplete | None = ..., create_method: bool = ...): ...

class ProcessLocalSet(set):
    def __init__(self) -> None: ...
    def __reduce__(self): ...

class BaseProxy:
    def __init__(self, token, serializer, manager: Incomplete | None = ..., authkey: Incomplete | None = ..., exposed: Incomplete | None = ..., incref: bool = ..., manager_owned: bool = ...) -> None: ...
    def __reduce__(self): ...
    def __deepcopy__(self, memo): ...

class Namespace:
    def __init__(self, **kwds) -> None: ...

class Value:
    def __init__(self, typecode, value, lock: bool = ...) -> None: ...
    def get(self): ...
    def set(self, value) -> None: ...
    value: Incomplete

class IteratorProxy(BaseProxy):
    def __iter__(self): ...
    def __next__(self, *args): ...
    def send(self, *args): ...
    def throw(self, *args): ...
    def close(self, *args): ...

class AcquirerProxy(BaseProxy):
    def acquire(self, blocking: bool = ..., timeout: Incomplete | None = ...): ...
    def release(self): ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb): ...

class ConditionProxy(AcquirerProxy):
    def wait(self, timeout: Incomplete | None = ...): ...
    def notify(self, n: int = ...): ...
    def notify_all(self): ...
    def wait_for(self, predicate, timeout: Incomplete | None = ...): ...

class EventProxy(BaseProxy):
    def is_set(self): ...
    def set(self): ...
    def clear(self): ...
    def wait(self, timeout: Incomplete | None = ...): ...

class BarrierProxy(BaseProxy):
    def wait(self, timeout: Incomplete | None = ...): ...
    def abort(self): ...
    def reset(self): ...
    @property
    def parties(self): ...
    @property
    def n_waiting(self): ...
    @property
    def broken(self): ...

class NamespaceProxy(BaseProxy):
    def __getattr__(self, key): ...
    def __setattr__(self, key, value): ...
    def __delattr__(self, key): ...

class ValueProxy(BaseProxy):
    def get(self): ...
    def set(self, value): ...
    value: Incomplete
    __class_getitem__: Incomplete

class ListProxy(BaseListProxy):
    def __iadd__(self, value): ...
    def __imul__(self, value): ...

class PoolProxy(BasePoolProxy):
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...

class SyncManager(BaseManager): ...

class _SharedMemoryTracker:
    shared_memory_context_name: Incomplete
    segment_names: Incomplete
    def __init__(self, name, segment_names=...) -> None: ...
    def register_segment(self, segment_name) -> None: ...
    def destroy_segment(self, segment_name) -> None: ...
    def unlink(self) -> None: ...
    def __del__(self) -> None: ...

class SharedMemoryServer(Server):
    public: Incomplete
    shared_memory_context: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def create(self, c, typeid, *args, **kwargs): ...
    def shutdown(self, c): ...
    def track_segment(self, c, segment_name) -> None: ...
    def release_segment(self, c, segment_name) -> None: ...
    def list_segments(self, c): ...

class SharedMemoryManager(BaseManager):
    def __init__(self, *args, **kwargs) -> None: ...
    def __del__(self) -> None: ...
    def get_server(self): ...
    def SharedMemory(self, size): ...
    def ShareableList(self, sequence): ...
