from _typeshed import Incomplete
from contextlib import ContextDecorator
from pandas._typing import F as F, T as T
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Any, Callable, Iterable, Iterator, NamedTuple

class DeprecatedOption(NamedTuple):
    key: str
    msg: Union[str, None]
    rkey: Union[str, None]
    removal_ver: Union[str, None]

class RegisteredOption(NamedTuple):
    key: str
    defval: object
    doc: str
    validator: Union[Callable[[object], Any], None]
    cb: Union[Callable[[str], Any], None]

class OptionError(AttributeError, KeyError): ...

def get_default_val(pat: str): ...

class DictWrapper:
    def __init__(self, d: dict[str, Any], prefix: str = ...) -> None: ...
    def __setattr__(self, key: str, val: Any) -> None: ...
    def __getattr__(self, key: str): ...
    def __dir__(self) -> Iterable[str]: ...

class CallableDynamicDoc:
    __doc_tmpl__: Incomplete
    __func__: Incomplete
    def __init__(self, func: Callable[..., T], doc_tmpl: str) -> None: ...
    def __call__(self, *args, **kwds) -> T: ...
    @property
    def __doc__(self) -> str: ...

get_option: Incomplete
set_option: Incomplete
reset_option: Incomplete
describe_option: Incomplete
options: Incomplete

class option_context(ContextDecorator):
    ops: Incomplete
    def __init__(self, *args) -> None: ...
    undo: Incomplete
    def __enter__(self) -> None: ...
    def __exit__(self, *args) -> None: ...

def register_option(key: str, defval: object, doc: str = ..., validator: Union[Callable[[object], Any], None] = ..., cb: Union[Callable[[str], Any], None] = ...) -> None: ...
def deprecate_option(key: str, msg: Union[str, None] = ..., rkey: Union[str, None] = ..., removal_ver: Union[str, None] = ...) -> None: ...
def pp_options_list(keys: Iterable[str], width: int = ..., _print: bool = ...): ...
def config_prefix(prefix) -> Iterator[None]: ...
def is_type_factory(_type: type[Any]) -> Callable[[Any], None]: ...
def is_instance_factory(_type) -> Callable[[Any], None]: ...
def is_one_of_factory(legal_values) -> Callable[[Any], None]: ...
def is_nonnegative_int(value: object) -> None: ...

is_int: Incomplete
is_bool: Incomplete
is_float: Incomplete
is_str: Incomplete
is_text: Incomplete

def is_callable(obj) -> bool: ...
