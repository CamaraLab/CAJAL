import numpy as np
from _typeshed import Incomplete
from pandas import DataFrame as DataFrame, DatetimeIndex as DatetimeIndex, Index as Index, MultiIndex as MultiIndex, PeriodIndex as PeriodIndex, Series as Series, TimedeltaIndex as TimedeltaIndex, concat as concat, isna as isna
from pandas._config import config as config, get_option as get_option
from pandas._libs import lib as lib
from pandas._libs.tslibs import timezones as timezones
from pandas._typing import AnyArrayLike as AnyArrayLike, ArrayLike as ArrayLike, DtypeArg as DtypeArg, FilePath as FilePath, Shape as Shape, npt as npt
from pandas.compat._optional import import_optional_dependency as import_optional_dependency
from pandas.compat.pickle_compat import patch_pickle as patch_pickle
from pandas.core.api import Int64Index as Int64Index
from pandas.core.arrays import Categorical as Categorical, DatetimeArray as DatetimeArray, PeriodArray as PeriodArray
from pandas.core.computation.pytables import PyTablesExpr as PyTablesExpr, maybe_expression as maybe_expression
from pandas.core.construction import extract_array as extract_array
from pandas.core.dtypes.common import ensure_object as ensure_object, is_bool_dtype as is_bool_dtype, is_categorical_dtype as is_categorical_dtype, is_complex_dtype as is_complex_dtype, is_datetime64_dtype as is_datetime64_dtype, is_datetime64tz_dtype as is_datetime64tz_dtype, is_extension_array_dtype as is_extension_array_dtype, is_list_like as is_list_like, is_string_dtype as is_string_dtype, is_timedelta64_dtype as is_timedelta64_dtype, needs_i8_conversion as needs_i8_conversion
from pandas.core.dtypes.missing import array_equivalent as array_equivalent
from pandas.core.indexes.api import ensure_index as ensure_index
from pandas.core.internals import ArrayManager as ArrayManager, Block as Block, BlockManager as BlockManager
from pandas.errors import AttributeConflictWarning as AttributeConflictWarning, ClosedFileError as ClosedFileError, IncompatibilityWarning as IncompatibilityWarning, PerformanceWarning as PerformanceWarning, PossibleDataLossError as PossibleDataLossError
from pandas.io.common import stringify_path as stringify_path
from pandas.io.formats.printing import adjoin as adjoin, pprint_thing as pprint_thing
from pandas.util._decorators import cache_readonly as cache_readonly
from pandas.util._exceptions import find_stack_level as find_stack_level
from tables import Col as Col, File as File, Node as Node
from typing import Any, Final, Hashable, Iterator, Literal

Term = PyTablesExpr
incompatibility_doc: Final[str]
attribute_conflict_doc: Final[str]
performance_doc: Final[str]
dropna_doc: Final[str]
format_doc: Final[str]

def to_hdf(path_or_buf: Union[FilePath, HDFStore], key: str, value: Union[DataFrame, Series], mode: str = ..., complevel: Union[int, None] = ..., complib: Union[str, None] = ..., append: bool = ..., format: Union[str, None] = ..., index: bool = ..., min_itemsize: Union[int, dict[str, int], None] = ..., nan_rep: Incomplete | None = ..., dropna: Union[bool, None] = ..., data_columns: Union[Literal[True], list[str], None] = ..., errors: str = ..., encoding: str = ...) -> None: ...
def read_hdf(path_or_buf: Union[FilePath, HDFStore], key: Incomplete | None = ..., mode: str = ..., errors: str = ..., where: Union[str, list, None] = ..., start: Union[int, None] = ..., stop: Union[int, None] = ..., columns: Union[list[str], None] = ..., iterator: bool = ..., chunksize: Union[int, None] = ..., **kwargs): ...

class HDFStore:
    def __init__(self, path, mode: str = ..., complevel: Union[int, None] = ..., complib: Incomplete | None = ..., fletcher32: bool = ..., **kwargs) -> None: ...
    def __fspath__(self) -> str: ...
    @property
    def root(self): ...
    @property
    def filename(self) -> str: ...
    def __getitem__(self, key: str): ...
    def __setitem__(self, key: str, value) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __getattr__(self, name: str): ...
    def __contains__(self, key: str) -> bool: ...
    def __len__(self) -> int: ...
    def __enter__(self) -> HDFStore: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def keys(self, include: str = ...) -> list[str]: ...
    def __iter__(self) -> Iterator[str]: ...
    def items(self) -> Iterator[tuple[str, list]]: ...
    def iteritems(self) -> None: ...
    def open(self, mode: str = ..., **kwargs) -> None: ...
    def close(self) -> None: ...
    @property
    def is_open(self) -> bool: ...
    def flush(self, fsync: bool = ...) -> None: ...
    def get(self, key: str): ...
    def select(self, key: str, where: Incomplete | None = ..., start: Incomplete | None = ..., stop: Incomplete | None = ..., columns: Incomplete | None = ..., iterator: bool = ..., chunksize: Incomplete | None = ..., auto_close: bool = ...): ...
    def select_as_coordinates(self, key: str, where: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...): ...
    def select_column(self, key: str, column: str, start: Union[int, None] = ..., stop: Union[int, None] = ...): ...
    def select_as_multiple(self, keys, where: Incomplete | None = ..., selector: Incomplete | None = ..., columns: Incomplete | None = ..., start: Incomplete | None = ..., stop: Incomplete | None = ..., iterator: bool = ..., chunksize: Incomplete | None = ..., auto_close: bool = ...): ...
    def put(self, key: str, value: Union[DataFrame, Series], format: Incomplete | None = ..., index: bool = ..., append: bool = ..., complib: Incomplete | None = ..., complevel: Union[int, None] = ..., min_itemsize: Union[int, dict[str, int], None] = ..., nan_rep: Incomplete | None = ..., data_columns: Union[Literal[True], list[str], None] = ..., encoding: Incomplete | None = ..., errors: str = ..., track_times: bool = ..., dropna: bool = ...) -> None: ...
    def remove(self, key: str, where: Incomplete | None = ..., start: Incomplete | None = ..., stop: Incomplete | None = ...) -> None: ...
    def append(self, key: str, value: Union[DataFrame, Series], format: Incomplete | None = ..., axes: Incomplete | None = ..., index: bool = ..., append: bool = ..., complib: Incomplete | None = ..., complevel: Union[int, None] = ..., columns: Incomplete | None = ..., min_itemsize: Union[int, dict[str, int], None] = ..., nan_rep: Incomplete | None = ..., chunksize: Incomplete | None = ..., expectedrows: Incomplete | None = ..., dropna: Union[bool, None] = ..., data_columns: Union[Literal[True], list[str], None] = ..., encoding: Incomplete | None = ..., errors: str = ...) -> None: ...
    def append_to_multiple(self, d: dict, value, selector, data_columns: Incomplete | None = ..., axes: Incomplete | None = ..., dropna: bool = ..., **kwargs) -> None: ...
    def create_table_index(self, key: str, columns: Incomplete | None = ..., optlevel: Union[int, None] = ..., kind: Union[str, None] = ...) -> None: ...
    def groups(self) -> list: ...
    def walk(self, where: str = ...) -> Iterator[tuple[str, list[str], list[str]]]: ...
    def get_node(self, key: str) -> Union[Node, None]: ...
    def get_storer(self, key: str) -> Union[GenericFixed, Table]: ...
    def copy(self, file, mode: str = ..., propindexes: bool = ..., keys: Incomplete | None = ..., complib: Incomplete | None = ..., complevel: Union[int, None] = ..., fletcher32: bool = ..., overwrite: bool = ...) -> HDFStore: ...
    def info(self) -> str: ...

class TableIterator:
    chunksize: Union[int, None]
    store: HDFStore
    s: Union[GenericFixed, Table]
    func: Incomplete
    where: Incomplete
    nrows: Incomplete
    start: Incomplete
    stop: Incomplete
    coordinates: Incomplete
    auto_close: Incomplete
    def __init__(self, store: HDFStore, s: Union[GenericFixed, Table], func, where, nrows, start: Incomplete | None = ..., stop: Incomplete | None = ..., iterator: bool = ..., chunksize: Union[int, None] = ..., auto_close: bool = ...) -> None: ...
    def __iter__(self): ...
    def close(self) -> None: ...
    def get_result(self, coordinates: bool = ...): ...

class IndexCol:
    is_an_indexable: bool
    is_data_indexable: bool
    name: str
    cname: str
    values: Incomplete
    kind: Incomplete
    typ: Incomplete
    axis: Incomplete
    pos: Incomplete
    freq: Incomplete
    tz: Incomplete
    index_name: Incomplete
    ordered: Incomplete
    table: Incomplete
    meta: Incomplete
    metadata: Incomplete
    def __init__(self, name: str, values: Incomplete | None = ..., kind: Incomplete | None = ..., typ: Incomplete | None = ..., cname: Union[str, None] = ..., axis: Incomplete | None = ..., pos: Incomplete | None = ..., freq: Incomplete | None = ..., tz: Incomplete | None = ..., index_name: Incomplete | None = ..., ordered: Incomplete | None = ..., table: Incomplete | None = ..., meta: Incomplete | None = ..., metadata: Incomplete | None = ...) -> None: ...
    @property
    def itemsize(self) -> int: ...
    @property
    def kind_attr(self) -> str: ...
    def set_pos(self, pos: int) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other) -> bool: ...
    @property
    def is_indexed(self) -> bool: ...
    def convert(self, values: np.ndarray, nan_rep, encoding: str, errors: str) -> Union[tuple[np.ndarray, np.ndarray], tuple[DatetimeIndex, DatetimeIndex]]: ...
    def take_data(self): ...
    @property
    def attrs(self): ...
    @property
    def description(self): ...
    @property
    def col(self): ...
    @property
    def cvalues(self): ...
    def __iter__(self): ...
    def maybe_set_size(self, min_itemsize: Incomplete | None = ...) -> None: ...
    def validate_names(self) -> None: ...
    def validate_and_set(self, handler: AppendableTable, append: bool) -> None: ...
    def validate_col(self, itemsize: Incomplete | None = ...): ...
    def validate_attr(self, append: bool) -> None: ...
    def update_info(self, info) -> None: ...
    def set_info(self, info) -> None: ...
    def set_attr(self) -> None: ...
    def validate_metadata(self, handler: AppendableTable) -> None: ...
    def write_metadata(self, handler: AppendableTable) -> None: ...

class GenericIndexCol(IndexCol):
    @property
    def is_indexed(self) -> bool: ...
    def convert(self, values: np.ndarray, nan_rep, encoding: str, errors: str) -> tuple[Int64Index, Int64Index]: ...
    def set_attr(self) -> None: ...

class DataCol(IndexCol):
    is_an_indexable: bool
    is_data_indexable: bool
    dtype: Incomplete
    data: Incomplete
    def __init__(self, name: str, values: Incomplete | None = ..., kind: Incomplete | None = ..., typ: Incomplete | None = ..., cname: Incomplete | None = ..., pos: Incomplete | None = ..., tz: Incomplete | None = ..., ordered: Incomplete | None = ..., table: Incomplete | None = ..., meta: Incomplete | None = ..., metadata: Incomplete | None = ..., dtype: Union[DtypeArg, None] = ..., data: Incomplete | None = ...) -> None: ...
    @property
    def dtype_attr(self) -> str: ...
    @property
    def meta_attr(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    kind: Incomplete
    def set_data(self, data: ArrayLike) -> None: ...
    def take_data(self): ...
    @classmethod
    def get_atom_string(cls, shape, itemsize): ...
    @classmethod
    def get_atom_coltype(cls, kind: str) -> type[Col]: ...
    @classmethod
    def get_atom_data(cls, shape, kind: str) -> Col: ...
    @classmethod
    def get_atom_datetime64(cls, shape): ...
    @classmethod
    def get_atom_timedelta64(cls, shape): ...
    @property
    def shape(self): ...
    @property
    def cvalues(self): ...
    def validate_attr(self, append) -> None: ...
    def convert(self, values: np.ndarray, nan_rep, encoding: str, errors: str): ...
    def set_attr(self) -> None: ...

class DataIndexableCol(DataCol):
    is_data_indexable: bool
    def validate_names(self) -> None: ...
    @classmethod
    def get_atom_string(cls, shape, itemsize): ...
    @classmethod
    def get_atom_data(cls, shape, kind: str) -> Col: ...
    @classmethod
    def get_atom_datetime64(cls, shape): ...
    @classmethod
    def get_atom_timedelta64(cls, shape): ...

class GenericDataIndexableCol(DataIndexableCol): ...

class Fixed:
    pandas_kind: str
    format_type: str
    obj_type: type[Union[DataFrame, Series]]
    ndim: int
    encoding: str
    parent: HDFStore
    group: Node
    errors: str
    is_table: bool
    def __init__(self, parent: HDFStore, group: Node, encoding: str = ..., errors: str = ...) -> None: ...
    @property
    def is_old_version(self) -> bool: ...
    @property
    def version(self) -> tuple[int, int, int]: ...
    @property
    def pandas_type(self): ...
    def set_object_info(self) -> None: ...
    def copy(self) -> Fixed: ...
    @property
    def shape(self): ...
    @property
    def pathname(self): ...
    @property
    def attrs(self): ...
    def set_attrs(self) -> None: ...
    def get_attrs(self) -> None: ...
    @property
    def storable(self): ...
    @property
    def is_exists(self) -> bool: ...
    @property
    def nrows(self): ...
    def validate(self, other) -> Union[Literal[True], None]: ...
    def validate_version(self, where: Incomplete | None = ...) -> None: ...
    def infer_axes(self) -> bool: ...
    def read(self, where: Incomplete | None = ..., columns: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...): ...
    def write(self, **kwargs) -> None: ...
    def delete(self, where: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...) -> None: ...

class GenericFixed(Fixed):
    attributes: list[str]
    def validate_read(self, columns, where) -> None: ...
    @property
    def is_exists(self) -> bool: ...
    def set_attrs(self) -> None: ...
    encoding: Incomplete
    errors: Incomplete
    def get_attrs(self) -> None: ...
    def write(self, obj, **kwargs) -> None: ...
    def read_array(self, key: str, start: Union[int, None] = ..., stop: Union[int, None] = ...): ...
    def read_index(self, key: str, start: Union[int, None] = ..., stop: Union[int, None] = ...) -> Index: ...
    def write_index(self, key: str, index: Index) -> None: ...
    def write_multi_index(self, key: str, index: MultiIndex) -> None: ...
    def read_multi_index(self, key: str, start: Union[int, None] = ..., stop: Union[int, None] = ...) -> MultiIndex: ...
    def read_index_node(self, node: Node, start: Union[int, None] = ..., stop: Union[int, None] = ...) -> Index: ...
    def write_array_empty(self, key: str, value: ArrayLike) -> None: ...
    def write_array(self, key: str, obj: AnyArrayLike, items: Union[Index, None] = ...) -> None: ...

class SeriesFixed(GenericFixed):
    pandas_kind: str
    attributes: Incomplete
    name: Hashable
    @property
    def shape(self): ...
    def read(self, where: Incomplete | None = ..., columns: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...) -> Series: ...
    def write(self, obj, **kwargs) -> None: ...

class BlockManagerFixed(GenericFixed):
    attributes: Incomplete
    nblocks: int
    @property
    def shape(self) -> Union[Shape, None]: ...
    def read(self, where: Incomplete | None = ..., columns: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...) -> DataFrame: ...
    def write(self, obj, **kwargs) -> None: ...

class FrameFixed(BlockManagerFixed):
    pandas_kind: str
    obj_type: Incomplete

class Table(Fixed):
    pandas_kind: str
    format_type: str
    table_type: str
    levels: Union[int, list[Hashable]]
    is_table: bool
    index_axes: list[IndexCol]
    non_index_axes: list[tuple[int, Any]]
    values_axes: list[DataCol]
    data_columns: list
    metadata: list
    info: dict
    nan_rep: Incomplete
    def __init__(self, parent: HDFStore, group: Node, encoding: Incomplete | None = ..., errors: str = ..., index_axes: Incomplete | None = ..., non_index_axes: Incomplete | None = ..., values_axes: Incomplete | None = ..., data_columns: Incomplete | None = ..., info: Incomplete | None = ..., nan_rep: Incomplete | None = ...) -> None: ...
    @property
    def table_type_short(self) -> str: ...
    def __getitem__(self, c: str): ...
    def validate(self, other) -> None: ...
    @property
    def is_multi_index(self) -> bool: ...
    def validate_multiindex(self, obj: Union[DataFrame, Series]) -> tuple[DataFrame, list[Hashable]]: ...
    @property
    def nrows_expected(self) -> int: ...
    @property
    def is_exists(self) -> bool: ...
    @property
    def storable(self): ...
    @property
    def table(self): ...
    @property
    def dtype(self): ...
    @property
    def description(self): ...
    @property
    def axes(self): ...
    @property
    def ncols(self) -> int: ...
    @property
    def is_transposed(self) -> bool: ...
    @property
    def data_orientation(self) -> tuple[int, ...]: ...
    def queryables(self) -> dict[str, Any]: ...
    def index_cols(self): ...
    def values_cols(self) -> list[str]: ...
    def write_metadata(self, key: str, values: np.ndarray) -> None: ...
    def read_metadata(self, key: str): ...
    def set_attrs(self) -> None: ...
    encoding: Incomplete
    errors: Incomplete
    def get_attrs(self) -> None: ...
    def validate_version(self, where: Incomplete | None = ...) -> None: ...
    def validate_min_itemsize(self, min_itemsize) -> None: ...
    def indexables(self): ...
    def create_index(self, columns: Incomplete | None = ..., optlevel: Incomplete | None = ..., kind: Union[str, None] = ...) -> None: ...
    @classmethod
    def get_object(cls, obj, transposed: bool): ...
    def validate_data_columns(self, data_columns, min_itemsize, non_index_axes): ...
    def process_axes(self, obj, selection: Selection, columns: Incomplete | None = ...) -> DataFrame: ...
    def create_description(self, complib, complevel: Union[int, None], fletcher32: bool, expectedrows: Union[int, None]) -> dict[str, Any]: ...
    def read_coordinates(self, where: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...): ...
    def read_column(self, column: str, where: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...): ...

class WORMTable(Table):
    table_type: str
    def read(self, where: Incomplete | None = ..., columns: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...): ...
    def write(self, **kwargs) -> None: ...

class AppendableTable(Table):
    table_type: str
    def write(self, obj, axes: Incomplete | None = ..., append: bool = ..., complib: Incomplete | None = ..., complevel: Incomplete | None = ..., fletcher32: Incomplete | None = ..., min_itemsize: Incomplete | None = ..., chunksize: Incomplete | None = ..., expectedrows: Incomplete | None = ..., dropna: bool = ..., nan_rep: Incomplete | None = ..., data_columns: Incomplete | None = ..., track_times: bool = ...) -> None: ...
    def write_data(self, chunksize: Union[int, None], dropna: bool = ...) -> None: ...
    def write_data_chunk(self, rows: np.ndarray, indexes: list[np.ndarray], mask: Union[npt.NDArray[np.bool_], None], values: list[np.ndarray]) -> None: ...
    def delete(self, where: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...): ...

class AppendableFrameTable(AppendableTable):
    pandas_kind: str
    table_type: str
    ndim: int
    obj_type: type[Union[DataFrame, Series]]
    @property
    def is_transposed(self) -> bool: ...
    @classmethod
    def get_object(cls, obj, transposed: bool): ...
    def read(self, where: Incomplete | None = ..., columns: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...): ...

class AppendableSeriesTable(AppendableFrameTable):
    pandas_kind: str
    table_type: str
    ndim: int
    obj_type: Incomplete
    @property
    def is_transposed(self) -> bool: ...
    @classmethod
    def get_object(cls, obj, transposed: bool): ...
    def write(self, obj, data_columns: Incomplete | None = ..., **kwargs): ...
    def read(self, where: Incomplete | None = ..., columns: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...) -> Series: ...

class AppendableMultiSeriesTable(AppendableSeriesTable):
    pandas_kind: str
    table_type: str
    def write(self, obj, **kwargs): ...

class GenericTable(AppendableFrameTable):
    pandas_kind: str
    table_type: str
    ndim: int
    obj_type: Incomplete
    levels: list[Hashable]
    @property
    def pandas_type(self) -> str: ...
    @property
    def storable(self): ...
    non_index_axes: Incomplete
    nan_rep: Incomplete
    index_axes: Incomplete
    values_axes: Incomplete
    data_columns: Incomplete
    def get_attrs(self) -> None: ...
    def indexables(self): ...
    def write(self, **kwargs) -> None: ...

class AppendableMultiFrameTable(AppendableFrameTable):
    table_type: str
    obj_type: Incomplete
    ndim: int
    @property
    def table_type_short(self) -> str: ...
    def write(self, obj, data_columns: Incomplete | None = ..., **kwargs): ...
    def read(self, where: Incomplete | None = ..., columns: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...): ...

class Selection:
    table: Incomplete
    where: Incomplete
    start: Incomplete
    stop: Incomplete
    condition: Incomplete
    filter: Incomplete
    terms: Incomplete
    coordinates: Incomplete
    def __init__(self, table: Table, where: Incomplete | None = ..., start: Union[int, None] = ..., stop: Union[int, None] = ...) -> None: ...
    def generate(self, where): ...
    def select(self): ...
    def select_coords(self): ...
