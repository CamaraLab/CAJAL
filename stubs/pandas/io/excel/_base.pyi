import abc
from _typeshed import Incomplete
from pandas._config import config as config
from pandas._libs.parsers import STR_NA_VALUES as STR_NA_VALUES
from pandas._typing import DtypeArg as DtypeArg, FilePath as FilePath, IntStrT as IntStrT, ReadBuffer as ReadBuffer, StorageOptions as StorageOptions, WriteExcelBuffer as WriteExcelBuffer
from pandas.compat._optional import get_version as get_version, import_optional_dependency as import_optional_dependency
from pandas.core.dtypes.common import is_bool as is_bool, is_float as is_float, is_integer as is_integer, is_list_like as is_list_like
from pandas.core.frame import DataFrame as DataFrame
from pandas.errors import EmptyDataError as EmptyDataError
from pandas.io.common import IOHandles as IOHandles, get_handle as get_handle, stringify_path as stringify_path, validate_header_arg as validate_header_arg
from pandas.io.excel._odfreader import ODFReader as ODFReader
from pandas.io.excel._openpyxl import OpenpyxlReader as OpenpyxlReader
from pandas.io.excel._pyxlsb import PyxlsbReader as PyxlsbReader
from pandas.io.excel._util import fill_mi_header as fill_mi_header, get_default_engine as get_default_engine, get_writer as get_writer, maybe_convert_usecols as maybe_convert_usecols, pop_header_name as pop_header_name
from pandas.io.excel._xlrd import XlrdReader as XlrdReader
from pandas.io.parsers import TextParser as TextParser
from pandas.io.parsers.readers import validate_integer as validate_integer
from pandas.util._decorators import Appender as Appender, deprecate_kwarg as deprecate_kwarg, deprecate_nonkeyword_arguments as deprecate_nonkeyword_arguments, doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level
from pandas.util.version import Version as Version
from typing import Any, Callable, Hashable, Iterable, Literal, Sequence, overload

@overload
def read_excel(io, sheet_name: Union[str, int] = ..., header: Union[int, Sequence[int], None] = ..., names: Union[list[str], None] = ..., index_col: Union[int, Sequence[int], None] = ..., usecols: Union[int, str, Sequence[int], Sequence[str], Callable[[str], bool], None] = ..., squeeze: Union[bool, None] = ..., dtype: Union[DtypeArg, None] = ..., engine: Union[Literal['xlrd', 'openpyxl', 'odf', 'pyxlsb'], None] = ..., converters: Union[dict[str, Callable], dict[int, Callable], None] = ..., true_values: Union[Iterable[Hashable], None] = ..., false_values: Union[Iterable[Hashable], None] = ..., skiprows: Union[Sequence[int], int, Callable[[int], object], None] = ..., nrows: Union[int, None] = ..., na_values=..., keep_default_na: bool = ..., na_filter: bool = ..., verbose: bool = ..., parse_dates: Union[list, dict, bool] = ..., date_parser: Union[Callable, None] = ..., thousands: Union[str, None] = ..., decimal: str = ..., comment: Union[str, None] = ..., skipfooter: int = ..., convert_float: Union[bool, None] = ..., mangle_dupe_cols: bool = ..., storage_options: StorageOptions = ...) -> DataFrame: ...
@overload
def read_excel(io, sheet_name: Union[list[IntStrT], None], header: Union[int, Sequence[int], None] = ..., names: Union[list[str], None] = ..., index_col: Union[int, Sequence[int], None] = ..., usecols: Union[int, str, Sequence[int], Sequence[str], Callable[[str], bool], None] = ..., squeeze: Union[bool, None] = ..., dtype: Union[DtypeArg, None] = ..., engine: Union[Literal['xlrd', 'openpyxl', 'odf', 'pyxlsb'], None] = ..., converters: Union[dict[str, Callable], dict[int, Callable], None] = ..., true_values: Union[Iterable[Hashable], None] = ..., false_values: Union[Iterable[Hashable], None] = ..., skiprows: Union[Sequence[int], int, Callable[[int], object], None] = ..., nrows: Union[int, None] = ..., na_values=..., keep_default_na: bool = ..., na_filter: bool = ..., verbose: bool = ..., parse_dates: Union[list, dict, bool] = ..., date_parser: Union[Callable, None] = ..., thousands: Union[str, None] = ..., decimal: str = ..., comment: Union[str, None] = ..., skipfooter: int = ..., convert_float: Union[bool, None] = ..., mangle_dupe_cols: bool = ..., storage_options: StorageOptions = ...) -> dict[IntStrT, DataFrame]: ...

class BaseExcelReader(metaclass=abc.ABCMeta):
    handles: Incomplete
    book: Incomplete
    def __init__(self, filepath_or_buffer, storage_options: StorageOptions = ...) -> None: ...
    @abc.abstractmethod
    def load_workbook(self, filepath_or_buffer): ...
    def close(self) -> None: ...
    @property
    @abc.abstractmethod
    def sheet_names(self) -> list[str]: ...
    @abc.abstractmethod
    def get_sheet_by_name(self, name: str): ...
    @abc.abstractmethod
    def get_sheet_by_index(self, index: int): ...
    @abc.abstractmethod
    def get_sheet_data(self, sheet, convert_float: bool, rows: Union[int, None] = ...): ...
    def raise_if_bad_sheet_by_index(self, index: int) -> None: ...
    def raise_if_bad_sheet_by_name(self, name: str) -> None: ...
    def parse(self, sheet_name: Union[str, int, list[int], list[str], None] = ..., header: Union[int, Sequence[int], None] = ..., names: Incomplete | None = ..., index_col: Union[int, Sequence[int], None] = ..., usecols: Incomplete | None = ..., squeeze: Union[bool, None] = ..., dtype: Union[DtypeArg, None] = ..., true_values: Union[Iterable[Hashable], None] = ..., false_values: Union[Iterable[Hashable], None] = ..., skiprows: Union[Sequence[int], int, Callable[[int], object], None] = ..., nrows: Union[int, None] = ..., na_values: Incomplete | None = ..., verbose: bool = ..., parse_dates: Union[list, dict, bool] = ..., date_parser: Union[Callable, None] = ..., thousands: Union[str, None] = ..., decimal: str = ..., comment: Union[str, None] = ..., skipfooter: int = ..., convert_float: Union[bool, None] = ..., mangle_dupe_cols: bool = ..., **kwds): ...

class ExcelWriter(metaclass=abc.ABCMeta):
    def __new__(cls, path: Union[FilePath, WriteExcelBuffer, ExcelWriter], engine: Union[str, None] = ..., date_format: Union[str, None] = ..., datetime_format: Union[str, None] = ..., mode: str = ..., storage_options: StorageOptions = ..., if_sheet_exists: Union[Literal['error', 'new', 'replace', 'overlay'], None] = ..., engine_kwargs: Union[dict, None] = ..., **kwargs) -> ExcelWriter: ...
    @property
    def supported_extensions(self) -> tuple[str, ...]: ...
    @property
    def engine(self) -> str: ...
    @property
    @abc.abstractmethod
    def sheets(self) -> dict[str, Any]: ...
    @property
    @abc.abstractmethod
    def book(self): ...
    @book.setter
    @abc.abstractmethod
    def book(self, other) -> None: ...
    def write_cells(self, cells, sheet_name: Union[str, None] = ..., startrow: int = ..., startcol: int = ..., freeze_panes: Union[tuple[int, int], None] = ...) -> None: ...
    def save(self) -> None: ...
    def __init__(self, path: Union[FilePath, WriteExcelBuffer, ExcelWriter], engine: Union[str, None] = ..., date_format: Union[str, None] = ..., datetime_format: Union[str, None] = ..., mode: str = ..., storage_options: StorageOptions = ..., if_sheet_exists: Union[str, None] = ..., engine_kwargs: Union[dict[str, Any], None] = ..., **kwargs) -> None: ...
    @property
    def date_format(self) -> str: ...
    @property
    def datetime_format(self) -> str: ...
    @property
    def if_sheet_exists(self) -> str: ...
    @property
    def cur_sheet(self): ...
    @property
    def handles(self) -> IOHandles[bytes]: ...
    @property
    def path(self): ...
    def __fspath__(self) -> str: ...
    @classmethod
    def check_extension(cls, ext: str) -> Literal[True]: ...
    def __enter__(self) -> ExcelWriter: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def close(self) -> None: ...

XLS_SIGNATURES: Incomplete
ZIP_SIGNATURE: bytes
PEEK_SIZE: Incomplete

def inspect_excel_format(content_or_path: Union[FilePath, ReadBuffer[bytes]], storage_options: StorageOptions = ...) -> Union[str, None]: ...

class ExcelFile:
    io: Incomplete
    engine: Incomplete
    storage_options: Incomplete
    def __init__(self, path_or_buffer, engine: Union[str, None] = ..., storage_options: StorageOptions = ...) -> None: ...
    def __fspath__(self): ...
    def parse(self, sheet_name: Union[str, int, list[int], list[str], None] = ..., header: Union[int, Sequence[int], None] = ..., names: Incomplete | None = ..., index_col: Union[int, Sequence[int], None] = ..., usecols: Incomplete | None = ..., squeeze: Union[bool, None] = ..., converters: Incomplete | None = ..., true_values: Union[Iterable[Hashable], None] = ..., false_values: Union[Iterable[Hashable], None] = ..., skiprows: Union[Sequence[int], int, Callable[[int], object], None] = ..., nrows: Union[int, None] = ..., na_values: Incomplete | None = ..., parse_dates: Union[list, dict, bool] = ..., date_parser: Union[Callable, None] = ..., thousands: Union[str, None] = ..., comment: Union[str, None] = ..., skipfooter: int = ..., convert_float: Union[bool, None] = ..., mangle_dupe_cols: bool = ..., **kwds) -> Union[DataFrame, dict[str, DataFrame], dict[int, DataFrame]]: ...
    @property
    def book(self): ...
    @property
    def sheet_names(self): ...
    def close(self) -> None: ...
    def __enter__(self) -> ExcelFile: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def __del__(self) -> None: ...
