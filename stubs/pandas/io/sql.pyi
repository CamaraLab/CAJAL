import numpy as np
from _typeshed import Incomplete
from collections.abc import Generator
from pandas import get_option as get_option
from pandas._typing import DateTimeErrorChoices as DateTimeErrorChoices, DtypeArg as DtypeArg, IndexLabel as IndexLabel
from pandas.compat._optional import import_optional_dependency as import_optional_dependency
from pandas.core.api import DataFrame as DataFrame, Series as Series
from pandas.core.base import PandasObject as PandasObject
from pandas.core.dtypes.common import is_datetime64tz_dtype as is_datetime64tz_dtype, is_dict_like as is_dict_like, is_integer as is_integer, is_list_like as is_list_like
from pandas.core.dtypes.dtypes import DatetimeTZDtype as DatetimeTZDtype
from pandas.core.dtypes.missing import isna as isna
from pandas.core.tools.datetimes import to_datetime as to_datetime
from pandas.errors import AbstractMethodError as AbstractMethodError, DatabaseError as DatabaseError
from pandas.util._exceptions import find_stack_level as find_stack_level
from sqlalchemy import Table
from typing import Iterator, overload

def execute(sql, con, params: Incomplete | None = ...): ...
@overload
def read_sql_table(table_name, con, schema=..., index_col: Union[str, list[str], None] = ..., coerce_float=..., parse_dates: Union[list[str], dict[str, str], None] = ..., columns: Union[list[str], None] = ..., chunksize: None = ...) -> DataFrame: ...
@overload
def read_sql_table(table_name, con, schema=..., index_col: Union[str, list[str], None] = ..., coerce_float=..., parse_dates: Union[list[str], dict[str, str], None] = ..., columns: Union[list[str], None] = ..., chunksize: int = ...) -> Iterator[DataFrame]: ...
@overload
def read_sql_query(sql, con, index_col: Union[str, list[str], None] = ..., coerce_float=..., params: Union[list[str], dict[str, str], None] = ..., parse_dates: Union[list[str], dict[str, str], None] = ..., chunksize: None = ..., dtype: Union[DtypeArg, None] = ...) -> DataFrame: ...
@overload
def read_sql_query(sql, con, index_col: Union[str, list[str], None] = ..., coerce_float=..., params: Union[list[str], dict[str, str], None] = ..., parse_dates: Union[list[str], dict[str, str], None] = ..., chunksize: int = ..., dtype: Union[DtypeArg, None] = ...) -> Iterator[DataFrame]: ...
@overload
def read_sql(sql, con, index_col: Union[str, list[str], None] = ..., coerce_float=..., params=..., parse_dates=..., columns: list[str] = ..., chunksize: None = ...) -> DataFrame: ...
@overload
def read_sql(sql, con, index_col: Union[str, list[str], None] = ..., coerce_float=..., params=..., parse_dates=..., columns: list[str] = ..., chunksize: int = ...) -> Iterator[DataFrame]: ...
def to_sql(frame, name: str, con, schema: Union[str, None] = ..., if_exists: str = ..., index: bool = ..., index_label: IndexLabel = ..., chunksize: Union[int, None] = ..., dtype: Union[DtypeArg, None] = ..., method: Union[str, None] = ..., engine: str = ..., **engine_kwargs) -> Union[int, None]: ...
def has_table(table_name: str, con, schema: Union[str, None] = ...) -> bool: ...
table_exists = has_table

def pandasSQL_builder(con, schema: Union[str, None] = ...) -> Union[SQLDatabase, SQLiteDatabase]: ...

class SQLTable(PandasObject):
    name: Incomplete
    pd_sql: Incomplete
    prefix: Incomplete
    frame: Incomplete
    index: Incomplete
    schema: Incomplete
    if_exists: Incomplete
    keys: Incomplete
    dtype: Incomplete
    table: Incomplete
    def __init__(self, name: str, pandas_sql_engine, frame: Incomplete | None = ..., index: Union[bool, str, list[str], None] = ..., if_exists: str = ..., prefix: str = ..., index_label: Incomplete | None = ..., schema: Incomplete | None = ..., keys: Incomplete | None = ..., dtype: Union[DtypeArg, None] = ...) -> None: ...
    def exists(self): ...
    def sql_schema(self) -> str: ...
    def create(self) -> None: ...
    def insert_data(self) -> tuple[list[str], list[np.ndarray]]: ...
    def insert(self, chunksize: Union[int, None] = ..., method: Union[str, None] = ...) -> Union[int, None]: ...
    def read(self, coerce_float: bool = ..., parse_dates: Incomplete | None = ..., columns: Incomplete | None = ..., chunksize: Incomplete | None = ...) -> Union[DataFrame, Iterator[DataFrame]]: ...

class PandasSQL(PandasObject):
    def read_sql(self, *args, **kwargs) -> None: ...
    def to_sql(self, frame, name, if_exists: str = ..., index: bool = ..., index_label: Incomplete | None = ..., schema: Incomplete | None = ..., chunksize: Incomplete | None = ..., dtype: Union[DtypeArg, None] = ..., method: Incomplete | None = ...) -> Union[int, None]: ...

class BaseEngine:
    def insert_records(self, table: SQLTable, con, frame, name, index: bool = ..., schema: Incomplete | None = ..., chunksize: Incomplete | None = ..., method: Incomplete | None = ..., **engine_kwargs) -> Union[int, None]: ...

class SQLAlchemyEngine(BaseEngine):
    def __init__(self) -> None: ...
    def insert_records(self, table: SQLTable, con, frame, name, index: bool = ..., schema: Incomplete | None = ..., chunksize: Incomplete | None = ..., method: Incomplete | None = ..., **engine_kwargs) -> Union[int, None]: ...

def get_engine(engine: str) -> BaseEngine: ...

class SQLDatabase(PandasSQL):
    connectable: Incomplete
    meta: Incomplete
    def __init__(self, engine, schema: Union[str, None] = ...) -> None: ...
    def run_transaction(self) -> Generator[Incomplete, None, None]: ...
    def execute(self, *args, **kwargs): ...
    def read_table(self, table_name: str, index_col: Union[str, list[str], None] = ..., coerce_float: bool = ..., parse_dates: Incomplete | None = ..., columns: Incomplete | None = ..., schema: Union[str, None] = ..., chunksize: Union[int, None] = ...) -> Union[DataFrame, Iterator[DataFrame]]: ...
    def read_query(self, sql: str, index_col: Union[str, list[str], None] = ..., coerce_float: bool = ..., parse_dates: Incomplete | None = ..., params: Incomplete | None = ..., chunksize: Union[int, None] = ..., dtype: Union[DtypeArg, None] = ...) -> Union[DataFrame, Iterator[DataFrame]]: ...
    read_sql: Incomplete
    def prep_table(self, frame, name, if_exists: str = ..., index: bool = ..., index_label: Incomplete | None = ..., schema: Incomplete | None = ..., dtype: Union[DtypeArg, None] = ...) -> SQLTable: ...
    def check_case_sensitive(self, name: str, schema: Union[str, None]) -> None: ...
    def to_sql(self, frame, name: str, if_exists: str = ..., index: bool = ..., index_label: Incomplete | None = ..., schema: Union[str, None] = ..., chunksize: Incomplete | None = ..., dtype: Union[DtypeArg, None] = ..., method: Incomplete | None = ..., engine: str = ..., **engine_kwargs) -> Union[int, None]: ...
    @property
    def tables(self): ...
    def has_table(self, name: str, schema: Union[str, None] = ...): ...
    def get_table(self, table_name: str, schema: Union[str, None] = ...) -> Table: ...
    def drop_table(self, table_name: str, schema: Union[str, None] = ...) -> None: ...

class SQLiteTable(SQLTable):
    def __init__(self, *args, **kwargs) -> None: ...
    def sql_schema(self) -> str: ...
    def insert_statement(self, *, num_rows: int) -> str: ...

class SQLiteDatabase(PandasSQL):
    con: Incomplete
    def __init__(self, con) -> None: ...
    def run_transaction(self) -> Generator[Incomplete, None, None]: ...
    def execute(self, *args, **kwargs): ...
    def read_query(self, sql, index_col: Incomplete | None = ..., coerce_float: bool = ..., params: Incomplete | None = ..., parse_dates: Incomplete | None = ..., chunksize: Union[int, None] = ..., dtype: Union[DtypeArg, None] = ...) -> Union[DataFrame, Iterator[DataFrame]]: ...
    def to_sql(self, frame, name, if_exists: str = ..., index: bool = ..., index_label: Incomplete | None = ..., schema: Incomplete | None = ..., chunksize: Incomplete | None = ..., dtype: Union[DtypeArg, None] = ..., method: Incomplete | None = ..., **kwargs) -> Union[int, None]: ...
    def has_table(self, name: str, schema: Union[str, None] = ...) -> bool: ...
    def get_table(self, table_name: str, schema: Union[str, None] = ...) -> None: ...
    def drop_table(self, name: str, schema: Union[str, None] = ...) -> None: ...

def get_schema(frame, name: str, keys: Incomplete | None = ..., con: Incomplete | None = ..., dtype: Union[DtypeArg, None] = ..., schema: Union[str, None] = ...) -> str: ...
