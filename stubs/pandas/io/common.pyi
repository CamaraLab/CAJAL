import abc
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from io import BytesIO, StringIO, TextIOBase
from pandas._typing import BaseBuffer as BaseBuffer, CompressionDict as CompressionDict, CompressionOptions as CompressionOptions, FilePath as FilePath, ReadBuffer as ReadBuffer, StorageOptions as StorageOptions, WriteBuffer as WriteBuffer
from pandas.compat import get_lzma_file as get_lzma_file
from pandas.compat._optional import import_optional_dependency as import_optional_dependency
from pandas.core.dtypes.common import is_bool as is_bool, is_file_like as is_file_like, is_integer as is_integer, is_list_like as is_list_like
from pandas.util._decorators import doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level
from pathlib import Path
from typing import Any, AnyStr, IO, Literal, TypeVar, overload

BaseBufferT = TypeVar('BaseBufferT', bound=BaseBuffer)

class IOArgs:
    filepath_or_buffer: Union[str, BaseBuffer]
    encoding: str
    mode: str
    compression: CompressionDict
    should_close: bool
    def __init__(self, filepath_or_buffer, encoding, mode, compression, should_close) -> None: ...

class IOHandles:
    handle: IO[AnyStr]
    compression: CompressionDict
    created_handles: list[Union[IO[bytes], IO[str]]]
    is_wrapped: bool
    def close(self) -> None: ...
    def __enter__(self) -> IOHandles[AnyStr]: ...
    def __exit__(self, *args: Any) -> None: ...
    def __init__(self, handle, compression, created_handles, is_wrapped) -> None: ...

def is_url(url: object) -> bool: ...
def validate_header_arg(header: object) -> None: ...
@overload
def stringify_path(filepath_or_buffer: FilePath, convert_file_like: bool = ...) -> str: ...
@overload
def stringify_path(filepath_or_buffer: BaseBufferT, convert_file_like: bool = ...) -> BaseBufferT: ...
def urlopen(*args, **kwargs): ...
def is_fsspec_url(url: Union[FilePath, BaseBuffer]) -> bool: ...
def file_path_to_url(path: str) -> str: ...
def get_compression_method(compression: CompressionOptions) -> tuple[Union[str, None], CompressionDict]: ...
def infer_compression(filepath_or_buffer: Union[FilePath, BaseBuffer], compression: Union[str, None]) -> Union[str, None]: ...
def check_parent_directory(path: Union[Path, str]) -> None: ...
@overload
def get_handle(path_or_buf: Union[FilePath, BaseBuffer], mode: str, *, encoding: Union[str, None] = ..., compression: CompressionOptions = ..., memory_map: bool = ..., is_text: Literal[False], errors: Union[str, None] = ..., storage_options: StorageOptions = ...) -> IOHandles[bytes]: ...
@overload
def get_handle(path_or_buf: Union[FilePath, BaseBuffer], mode: str, *, encoding: Union[str, None] = ..., compression: CompressionOptions = ..., memory_map: bool = ..., is_text: Literal[True] = ..., errors: Union[str, None] = ..., storage_options: StorageOptions = ...) -> IOHandles[str]: ...
@overload
def get_handle(path_or_buf: Union[FilePath, BaseBuffer], mode: str, *, encoding: Union[str, None] = ..., compression: CompressionOptions = ..., memory_map: bool = ..., is_text: bool = ..., errors: Union[str, None] = ..., storage_options: StorageOptions = ...) -> Union[IOHandles[str], IOHandles[bytes]]: ...

class _BufferedWriter(BytesIO, ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def write_to_buffer(self) -> None: ...
    def close(self) -> None: ...

class _BytesTarFile(_BufferedWriter):
    archive_name: Incomplete
    name: Incomplete
    buffer: Incomplete
    def __init__(self, name: Union[str, None] = ..., mode: Literal['r', 'a', 'w', 'x'] = ..., fileobj: Union[ReadBuffer[bytes], WriteBuffer[bytes], None] = ..., archive_name: Union[str, None] = ..., **kwargs) -> None: ...
    def extend_mode(self, mode: str) -> str: ...
    def infer_filename(self) -> Union[str, None]: ...
    def write_to_buffer(self) -> None: ...

class _BytesZipFile(_BufferedWriter):
    archive_name: Incomplete
    buffer: Incomplete
    def __init__(self, file: Union[FilePath, ReadBuffer[bytes], WriteBuffer[bytes]], mode: str, archive_name: Union[str, None] = ..., **kwargs) -> None: ...
    def infer_filename(self) -> Union[str, None]: ...
    def write_to_buffer(self) -> None: ...

class _IOWrapper:
    buffer: Incomplete
    def __init__(self, buffer: BaseBuffer) -> None: ...
    def __getattr__(self, name: str): ...
    def readable(self) -> bool: ...
    def seekable(self) -> bool: ...
    def writable(self) -> bool: ...

class _BytesIOWrapper:
    buffer: Incomplete
    encoding: Incomplete
    overflow: bytes
    def __init__(self, buffer: Union[StringIO, TextIOBase], encoding: str = ...) -> None: ...
    def __getattr__(self, attr: str): ...
    def read(self, n: Union[int, None] = ...) -> bytes: ...

def file_exists(filepath_or_buffer: Union[FilePath, BaseBuffer]) -> bool: ...
