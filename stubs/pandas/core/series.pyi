import numpy as np
from _typeshed import Incomplete
from pandas._libs import lib
from pandas._typing import AggFuncType, AnyArrayLike, ArrayLike, Axis, Dtype, DtypeObj, FilePath, FillnaOptions, Frequency, IgnoreRaise, IndexKeyFunc, IndexLabel, Level, NaPosition, NumpySorter, NumpyValueArrayLike, QuantileInterpolation, Renamer, SortKind, StorageOptions, Suffixes, TimedeltaConvertibleTypes, TimestampConvertibleTypes, ValueKeyFunc, WriteBuffer, npt
from pandas.core import base
from pandas.core.arrays import ExtensionArray
from pandas.core.frame import DataFrame
from pandas.core.generic import NDFrame
from pandas.core.groupby.generic import SeriesGroupBy
from pandas.core.indexes.api import Index
from pandas.core.resample import Resampler
from typing import Any, Callable, Hashable, IO, Iterable, Literal, Mapping, Sequence, overload

class Series(base.IndexOpsMixin, NDFrame):
    hasnans: Incomplete
    div: Callable[[Series, Any], Series]
    rdiv: Callable[[Series, Any], Series]
    def __init__(self, data: Incomplete | None = ..., index: Incomplete | None = ..., dtype: Union[Dtype, None] = ..., name: Incomplete | None = ..., copy: bool = ..., fastpath: bool = ...) -> None: ...
    @property
    def dtype(self) -> DtypeObj: ...
    @property
    def dtypes(self) -> DtypeObj: ...
    @property
    def name(self) -> Hashable: ...
    @name.setter
    def name(self, value: Hashable) -> None: ...
    @property
    def values(self): ...
    @property
    def array(self) -> ExtensionArray: ...
    def ravel(self, order: str = ...) -> np.ndarray: ...
    def __len__(self) -> int: ...
    def view(self, dtype: Union[Dtype, None] = ...) -> Series: ...
    def __array__(self, dtype: Union[npt.DTypeLike, None] = ...) -> np.ndarray: ...
    __float__: Incomplete
    __long__: Incomplete
    __int__: Incomplete
    @property
    def axes(self) -> list[Index]: ...
    def take(self, indices, axis: Axis = ..., is_copy: Union[bool, None] = ..., **kwargs) -> Series: ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...
    def repeat(self, repeats: Union[int, Sequence[int]], axis: None = ...) -> Series: ...
    @overload
    def reset_index(self, level: IndexLabel = ..., *, drop: Literal[False] = ..., name: Level = ..., inplace: Literal[False] = ..., allow_duplicates: bool = ...) -> DataFrame: ...
    @overload
    def reset_index(self, level: IndexLabel = ..., *, drop: Literal[True], name: Level = ..., inplace: Literal[False] = ..., allow_duplicates: bool = ...) -> Series: ...
    @overload
    def reset_index(self, level: IndexLabel = ..., *, drop: bool = ..., name: Level = ..., inplace: Literal[True], allow_duplicates: bool = ...) -> None: ...
    @overload
    def to_string(self, buf: None = ..., na_rep: str = ..., float_format: Union[str, None] = ..., header: bool = ..., index: bool = ..., length=..., dtype=..., name=..., max_rows: Union[int, None] = ..., min_rows: Union[int, None] = ...) -> str: ...
    @overload
    def to_string(self, buf: Union[FilePath, WriteBuffer[str]], na_rep: str = ..., float_format: Union[str, None] = ..., header: bool = ..., index: bool = ..., length=..., dtype=..., name=..., max_rows: Union[int, None] = ..., min_rows: Union[int, None] = ...) -> None: ...
    def to_markdown(self, buf: Union[IO[str], None] = ..., mode: str = ..., index: bool = ..., storage_options: StorageOptions = ..., **kwargs) -> Union[str, None]: ...
    def items(self) -> Iterable[tuple[Hashable, Any]]: ...
    def iteritems(self) -> Iterable[tuple[Hashable, Any]]: ...
    def keys(self) -> Index: ...
    def to_dict(self, into: type[dict] = ...) -> dict: ...
    def to_frame(self, name: Hashable = ...) -> DataFrame: ...
    def groupby(self, by: Incomplete | None = ..., axis: Axis = ..., level: Level = ..., as_index: bool = ..., sort: bool = ..., group_keys: Union[bool, lib.NoDefault] = ..., squeeze: Union[bool, lib.NoDefault] = ..., observed: bool = ..., dropna: bool = ...) -> SeriesGroupBy: ...
    def count(self, level: Level = ...): ...
    def mode(self, dropna: bool = ...) -> Series: ...
    def unique(self) -> ArrayLike: ...
    @overload
    def drop_duplicates(self, keep: Literal['first', 'last', False] = ..., *, inplace: Literal[False] = ...) -> Series: ...
    @overload
    def drop_duplicates(self, keep: Literal['first', 'last', False] = ..., *, inplace: Literal[True]) -> None: ...
    @overload
    def drop_duplicates(self, keep: Literal['first', 'last', False] = ..., *, inplace: bool = ...) -> Union[Series, None]: ...
    def duplicated(self, keep: Literal['first', 'last', False] = ...) -> Series: ...
    def idxmin(self, axis: Axis = ..., skipna: bool = ..., *args, **kwargs) -> Hashable: ...
    def idxmax(self, axis: Axis = ..., skipna: bool = ..., *args, **kwargs) -> Hashable: ...
    def round(self, decimals: int = ..., *args, **kwargs) -> Series: ...
    @overload
    def quantile(self, q: float = ..., interpolation: QuantileInterpolation = ...) -> float: ...
    @overload
    def quantile(self, q: Union[Sequence[float], AnyArrayLike], interpolation: QuantileInterpolation = ...) -> Series: ...
    @overload
    def quantile(self, q: Union[float, Sequence[float], AnyArrayLike] = ..., interpolation: QuantileInterpolation = ...) -> Union[float, Series]: ...
    def corr(self, other: Series, method: Union[Literal['pearson', 'kendall', 'spearman'], Callable[[np.ndarray, np.ndarray], float]] = ..., min_periods: Union[int, None] = ...) -> float: ...
    def cov(self, other: Series, min_periods: Union[int, None] = ..., ddof: Union[int, None] = ...) -> float: ...
    def diff(self, periods: int = ...) -> Series: ...
    def autocorr(self, lag: int = ...) -> float: ...
    def dot(self, other: AnyArrayLike) -> Union[Series, np.ndarray]: ...
    def __matmul__(self, other): ...
    def __rmatmul__(self, other): ...
    def searchsorted(self, value: Union[NumpyValueArrayLike, ExtensionArray], side: Literal['left', 'right'] = ..., sorter: NumpySorter = ...) -> Union[npt.NDArray[np.intp], np.intp]: ...
    def append(self, to_append, ignore_index: bool = ..., verify_integrity: bool = ...) -> Series: ...
    def compare(self, other: Series, align_axis: Axis = ..., keep_shape: bool = ..., keep_equal: bool = ..., result_names: Suffixes = ...) -> Union[DataFrame, Series]: ...
    def combine(self, other: Union[Series, Hashable], func: Callable[[Hashable, Hashable], Hashable], fill_value: Hashable = ...) -> Series: ...
    def combine_first(self, other) -> Series: ...
    def update(self, other: Union[Series, Sequence, Mapping]) -> None: ...
    @overload
    def sort_values(self, *, axis: Axis = ..., ascending: Union[bool, int, Sequence[bool], Sequence[int]] = ..., inplace: Literal[False] = ..., kind: str = ..., na_position: str = ..., ignore_index: bool = ..., key: ValueKeyFunc = ...) -> Series: ...
    @overload
    def sort_values(self, *, axis: Axis = ..., ascending: Union[bool, int, Sequence[bool], Sequence[int]] = ..., inplace: Literal[True], kind: str = ..., na_position: str = ..., ignore_index: bool = ..., key: ValueKeyFunc = ...) -> None: ...
    @overload
    def sort_index(self, *, axis: Axis = ..., level: IndexLabel = ..., ascending: Union[bool, Sequence[bool]] = ..., inplace: Literal[True], kind: SortKind = ..., na_position: NaPosition = ..., sort_remaining: bool = ..., ignore_index: bool = ..., key: IndexKeyFunc = ...) -> None: ...
    @overload
    def sort_index(self, *, axis: Axis = ..., level: IndexLabel = ..., ascending: Union[bool, Sequence[bool]] = ..., inplace: Literal[False] = ..., kind: SortKind = ..., na_position: NaPosition = ..., sort_remaining: bool = ..., ignore_index: bool = ..., key: IndexKeyFunc = ...) -> Series: ...
    @overload
    def sort_index(self, *, axis: Axis = ..., level: IndexLabel = ..., ascending: Union[bool, Sequence[bool]] = ..., inplace: bool = ..., kind: SortKind = ..., na_position: NaPosition = ..., sort_remaining: bool = ..., ignore_index: bool = ..., key: IndexKeyFunc = ...) -> Union[Series, None]: ...
    def argsort(self, axis: Axis = ..., kind: SortKind = ..., order: None = ...) -> Series: ...
    def nlargest(self, n: int = ..., keep: Literal['first', 'last', 'all'] = ...) -> Series: ...
    def nsmallest(self, n: int = ..., keep: str = ...) -> Series: ...
    def swaplevel(self, i: Level = ..., j: Level = ..., copy: bool = ...) -> Series: ...
    def reorder_levels(self, order: Sequence[Level]) -> Series: ...
    def explode(self, ignore_index: bool = ...) -> Series: ...
    def unstack(self, level: IndexLabel = ..., fill_value: Hashable = ...) -> DataFrame: ...
    def map(self, arg: Union[Callable, Mapping, Series], na_action: Union[Literal['ignore'], None] = ...) -> Series: ...
    def aggregate(self, func: Incomplete | None = ..., axis: Axis = ..., *args, **kwargs): ...
    agg: Incomplete
    @overload
    def any(self, *, axis: Axis = ..., bool_only: Union[bool, None] = ..., skipna: bool = ..., level: None = ..., **kwargs) -> bool: ...
    @overload
    def any(self, *, axis: Axis = ..., bool_only: Union[bool, None] = ..., skipna: bool = ..., level: Level, **kwargs) -> Union[Series, bool]: ...
    def transform(self, func: AggFuncType, axis: Axis = ..., *args, **kwargs) -> Union[DataFrame, Series]: ...
    def apply(self, func: AggFuncType, convert_dtype: bool = ..., args: tuple[Any, ...] = ..., **kwargs) -> Union[DataFrame, Series]: ...
    def align(self, other: Series, join: Literal['outer', 'inner', 'left', 'right'] = ..., axis: Union[Axis, None] = ..., level: Level = ..., copy: bool = ..., fill_value: Hashable = ..., method: Union[FillnaOptions, None] = ..., limit: Union[int, None] = ..., fill_axis: Axis = ..., broadcast_axis: Union[Axis, None] = ...) -> Series: ...
    @overload
    def rename(self, index: Union[Renamer, Hashable, None] = ..., *, axis: Union[Axis, None] = ..., copy: bool = ..., inplace: Literal[True], level: Union[Level, None] = ..., errors: IgnoreRaise = ...) -> None: ...
    @overload
    def rename(self, index: Union[Renamer, Hashable, None] = ..., *, axis: Union[Axis, None] = ..., copy: bool = ..., inplace: Literal[False] = ..., level: Union[Level, None] = ..., errors: IgnoreRaise = ...) -> Series: ...
    @overload
    def rename(self, index: Union[Renamer, Hashable, None] = ..., *, axis: Union[Axis, None] = ..., copy: bool = ..., inplace: bool = ..., level: Union[Level, None] = ..., errors: IgnoreRaise = ...) -> Union[Series, None]: ...
    @overload
    def set_axis(self, labels, *, axis: Axis = ..., inplace: Union[Literal[False], lib.NoDefault] = ..., copy: Union[bool, lib.NoDefault] = ...) -> Series: ...
    @overload
    def set_axis(self, labels, *, axis: Axis = ..., inplace: Literal[True], copy: Union[bool, lib.NoDefault] = ...) -> None: ...
    @overload
    def set_axis(self, labels, *, axis: Axis = ..., inplace: Union[bool, lib.NoDefault] = ..., copy: Union[bool, lib.NoDefault] = ...) -> Union[Series, None]: ...
    def reindex(self, *args, **kwargs) -> Series: ...
    @overload
    def drop(self, labels: IndexLabel = ..., *, axis: Axis = ..., index: IndexLabel = ..., columns: IndexLabel = ..., level: Union[Level, None] = ..., inplace: Literal[True], errors: IgnoreRaise = ...) -> None: ...
    @overload
    def drop(self, labels: IndexLabel = ..., *, axis: Axis = ..., index: IndexLabel = ..., columns: IndexLabel = ..., level: Union[Level, None] = ..., inplace: Literal[False] = ..., errors: IgnoreRaise = ...) -> Series: ...
    @overload
    def drop(self, labels: IndexLabel = ..., *, axis: Axis = ..., index: IndexLabel = ..., columns: IndexLabel = ..., level: Union[Level, None] = ..., inplace: bool = ..., errors: IgnoreRaise = ...) -> Union[Series, None]: ...
    @overload
    def fillna(self, value: Union[Hashable, Mapping, Series, DataFrame] = ..., *, method: Union[FillnaOptions, None] = ..., axis: Union[Axis, None] = ..., inplace: Literal[False] = ..., limit: Union[int, None] = ..., downcast: Union[dict, None] = ...) -> Series: ...
    @overload
    def fillna(self, value: Union[Hashable, Mapping, Series, DataFrame] = ..., *, method: Union[FillnaOptions, None] = ..., axis: Union[Axis, None] = ..., inplace: Literal[True], limit: Union[int, None] = ..., downcast: Union[dict, None] = ...) -> None: ...
    @overload
    def fillna(self, value: Union[Hashable, Mapping, Series, DataFrame] = ..., *, method: Union[FillnaOptions, None] = ..., axis: Union[Axis, None] = ..., inplace: bool = ..., limit: Union[int, None] = ..., downcast: Union[dict, None] = ...) -> Union[Series, None]: ...
    def pop(self, item: Hashable) -> Any: ...
    @overload
    def replace(self, to_replace=..., value=..., *, inplace: Literal[False] = ..., limit: Union[int, None] = ..., regex: bool = ..., method: Union[Literal['pad', 'ffill', 'bfill'], lib.NoDefault] = ...) -> Series: ...
    @overload
    def replace(self, to_replace=..., value=..., *, inplace: Literal[True], limit: Union[int, None] = ..., regex: bool = ..., method: Union[Literal['pad', 'ffill', 'bfill'], lib.NoDefault] = ...) -> None: ...
    def info(self, verbose: Union[bool, None] = ..., buf: Union[IO[str], None] = ..., max_cols: Union[int, None] = ..., memory_usage: Union[bool, str, None] = ..., show_counts: bool = ...) -> None: ...
    def shift(self, periods: int = ..., freq: Incomplete | None = ..., axis: Axis = ..., fill_value: Hashable = ...) -> Series: ...
    def memory_usage(self, index: bool = ..., deep: bool = ...) -> int: ...
    def isin(self, values) -> Series: ...
    def between(self, left, right, inclusive: Literal['both', 'neither', 'left', 'right'] = ...) -> Series: ...
    def isna(self) -> Series: ...
    def isnull(self) -> Series: ...
    def notna(self) -> Series: ...
    def notnull(self) -> Series: ...
    @overload
    def dropna(self, *, axis: Axis = ..., inplace: Literal[False] = ..., how: Union[str, None] = ...) -> Series: ...
    @overload
    def dropna(self, *, axis: Axis = ..., inplace: Literal[True], how: Union[str, None] = ...) -> None: ...
    def asfreq(self, freq: Frequency, method: Union[FillnaOptions, None] = ..., how: Union[str, None] = ..., normalize: bool = ..., fill_value: Hashable = ...) -> Series: ...
    def resample(self, rule, axis: Axis = ..., closed: Union[str, None] = ..., label: Union[str, None] = ..., convention: str = ..., kind: Union[str, None] = ..., loffset: Incomplete | None = ..., base: Union[int, None] = ..., on: Level = ..., level: Level = ..., origin: Union[str, TimestampConvertibleTypes] = ..., offset: Union[TimedeltaConvertibleTypes, None] = ..., group_keys: Union[bool, lib.NoDefault] = ...) -> Resampler: ...
    def to_timestamp(self, freq: Incomplete | None = ..., how: Literal['s', 'e', 'start', 'end'] = ..., copy: bool = ...) -> Series: ...
    def to_period(self, freq: Union[str, None] = ..., copy: bool = ...) -> Series: ...
    @overload
    def ffill(self, *, axis: Union[None, Axis] = ..., inplace: Literal[False] = ..., limit: Union[None, int] = ..., downcast: Union[dict, None] = ...) -> Series: ...
    @overload
    def ffill(self, *, axis: Union[None, Axis] = ..., inplace: Literal[True], limit: Union[None, int] = ..., downcast: Union[dict, None] = ...) -> None: ...
    @overload
    def ffill(self, *, axis: Union[None, Axis] = ..., inplace: bool = ..., limit: Union[None, int] = ..., downcast: Union[dict, None] = ...) -> Union[Series, None]: ...
    @overload
    def bfill(self, *, axis: Union[None, Axis] = ..., inplace: Literal[False] = ..., limit: Union[None, int] = ..., downcast: Union[dict, None] = ...) -> Series: ...
    @overload
    def bfill(self, *, axis: Union[None, Axis] = ..., inplace: Literal[True], limit: Union[None, int] = ..., downcast: Union[dict, None] = ...) -> None: ...
    @overload
    def bfill(self, *, axis: Union[None, Axis] = ..., inplace: bool = ..., limit: Union[None, int] = ..., downcast: Union[dict, None] = ...) -> Union[Series, None]: ...
    def clip(self, lower: Incomplete | None = ..., upper: Incomplete | None = ..., axis: Union[Axis, None] = ..., inplace: bool = ..., *args, **kwargs) -> Union[Series, None]: ...
    def interpolate(self, method: str = ..., axis: Axis = ..., limit: Union[int, None] = ..., inplace: bool = ..., limit_direction: Union[str, None] = ..., limit_area: Union[str, None] = ..., downcast: Union[str, None] = ..., **kwargs) -> Union[Series, None]: ...
    @overload
    def where(self, cond, other=..., *, inplace: Literal[False] = ..., axis: Union[Axis, None] = ..., level: Level = ..., errors: Union[IgnoreRaise, lib.NoDefault] = ..., try_cast: Union[bool, lib.NoDefault] = ...) -> Series: ...
    @overload
    def where(self, cond, other=..., *, inplace: Literal[True], axis: Union[Axis, None] = ..., level: Level = ..., errors: Union[IgnoreRaise, lib.NoDefault] = ..., try_cast: Union[bool, lib.NoDefault] = ...) -> None: ...
    @overload
    def where(self, cond, other=..., *, inplace: bool = ..., axis: Union[Axis, None] = ..., level: Level = ..., errors: Union[IgnoreRaise, lib.NoDefault] = ..., try_cast: Union[bool, lib.NoDefault] = ...) -> Union[Series, None]: ...
    @overload
    def mask(self, cond, other=..., *, inplace: Literal[False] = ..., axis: Union[Axis, None] = ..., level: Level = ..., errors: Union[IgnoreRaise, lib.NoDefault] = ..., try_cast: Union[bool, lib.NoDefault] = ...) -> Series: ...
    @overload
    def mask(self, cond, other=..., *, inplace: Literal[True], axis: Union[Axis, None] = ..., level: Level = ..., errors: Union[IgnoreRaise, lib.NoDefault] = ..., try_cast: Union[bool, lib.NoDefault] = ...) -> None: ...
    @overload
    def mask(self, cond, other=..., *, inplace: bool = ..., axis: Union[Axis, None] = ..., level: Level = ..., errors: Union[IgnoreRaise, lib.NoDefault] = ..., try_cast: Union[bool, lib.NoDefault] = ...) -> Union[Series, None]: ...
    index: Incomplete
    str: Incomplete
    dt: Incomplete
    cat: Incomplete
    plot: Incomplete
    sparse: Incomplete
    hist: Incomplete
