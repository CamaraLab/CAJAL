import numpy as np
from _typeshed import Incomplete
from pandas._config.config import option_context as option_context
from pandas._libs import Timestamp as Timestamp, lib as lib
from pandas._typing import ArrayLike as ArrayLike, IndexLabel as IndexLabel, NDFrameT as NDFrameT, PositionalIndexer as PositionalIndexer, RandomState as RandomState, Scalar as Scalar, T as T, npt as npt
from pandas.core import nanops as nanops
from pandas.core._numba import executor as executor
from pandas.core.arrays import BaseMaskedArray as BaseMaskedArray, BooleanArray as BooleanArray, Categorical as Categorical, ExtensionArray as ExtensionArray
from pandas.core.base import PandasObject as PandasObject, SelectionMixin as SelectionMixin
from pandas.core.dtypes.cast import ensure_dtype_can_hold_na as ensure_dtype_can_hold_na
from pandas.core.dtypes.common import is_bool_dtype as is_bool_dtype, is_datetime64_dtype as is_datetime64_dtype, is_float_dtype as is_float_dtype, is_integer as is_integer, is_integer_dtype as is_integer_dtype, is_numeric_dtype as is_numeric_dtype, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_timedelta64_dtype as is_timedelta64_dtype
from pandas.core.dtypes.missing import isna as isna, notna as notna
from pandas.core.frame import DataFrame as DataFrame
from pandas.core.generic import NDFrame as NDFrame
from pandas.core.groupby import base as base, numba_ as numba_, ops as ops
from pandas.core.groupby.indexing import GroupByIndexingMixin as GroupByIndexingMixin, GroupByNthSelector as GroupByNthSelector
from pandas.core.indexes.api import CategoricalIndex as CategoricalIndex, Index as Index, MultiIndex as MultiIndex, RangeIndex as RangeIndex
from pandas.core.internals.blocks import ensure_block_shape as ensure_block_shape
from pandas.core.series import Series as Series
from pandas.core.sorting import get_group_index_sorter as get_group_index_sorter
from pandas.core.util.numba_ import get_jit_arguments as get_jit_arguments, maybe_use_numba as maybe_use_numba
from pandas.core.window import ExpandingGroupby as ExpandingGroupby, ExponentialMovingWindowGroupby as ExponentialMovingWindowGroupby, RollingGroupby as RollingGroupby
from pandas.errors import AbstractMethodError as AbstractMethodError, DataError as DataError
from pandas.util._decorators import Appender as Appender, Substitution as Substitution, cache_readonly as cache_readonly, doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Callable, Hashable, Iterator, Sequence, TypeVar

class GroupByPlot(PandasObject):
    def __init__(self, groupby: GroupBy) -> None: ...
    def __call__(self, *args, **kwargs): ...
    def __getattr__(self, name: str): ...

class BaseGroupBy(PandasObject, SelectionMixin[NDFrameT], GroupByIndexingMixin):
    axis: int
    grouper: ops.BaseGrouper
    keys: Union[_KeysArgType, None]
    group_keys: Union[bool, lib.NoDefault]
    def __len__(self) -> int: ...
    @property
    def groups(self) -> dict[Hashable, np.ndarray]: ...
    @property
    def ngroups(self) -> int: ...
    @property
    def indices(self) -> dict[Hashable, npt.NDArray[np.intp]]: ...
    def pipe(self, func: Union[Callable[..., T], tuple[Callable[..., T], str]], *args, **kwargs) -> T: ...
    plot: Incomplete
    def get_group(self, name, obj: Incomplete | None = ...) -> Union[DataFrame, Series]: ...
    def __iter__(self) -> Iterator[tuple[Hashable, NDFrameT]]: ...
OutputFrameOrSeries = TypeVar('OutputFrameOrSeries', bound=NDFrame)

class GroupBy(BaseGroupBy[NDFrameT]):
    grouper: ops.BaseGrouper
    as_index: bool
    level: Incomplete
    keys: Incomplete
    sort: Incomplete
    group_keys: Incomplete
    squeeze: Incomplete
    observed: Incomplete
    mutated: Incomplete
    dropna: Incomplete
    obj: Incomplete
    axis: Incomplete
    exclusions: Incomplete
    def __init__(self, obj: NDFrameT, keys: Union[_KeysArgType, None] = ..., axis: int = ..., level: Union[IndexLabel, None] = ..., grouper: Union[ops.BaseGrouper, None] = ..., exclusions: Union[frozenset[Hashable], None] = ..., selection: Union[IndexLabel, None] = ..., as_index: bool = ..., sort: bool = ..., group_keys: Union[bool, lib.NoDefault] = ..., squeeze: bool = ..., observed: bool = ..., mutated: bool = ..., dropna: bool = ...) -> None: ...
    def __getattr__(self, attr: str): ...
    def apply(self, func, *args, **kwargs) -> NDFrameT: ...
    def any(self, skipna: bool = ...): ...
    def all(self, skipna: bool = ...): ...
    def count(self) -> NDFrameT: ...
    def mean(self, numeric_only: Union[bool, lib.NoDefault] = ..., engine: str = ..., engine_kwargs: Union[dict[str, bool], None] = ...): ...
    def median(self, numeric_only: Union[bool, lib.NoDefault] = ...): ...
    def std(self, ddof: int = ..., engine: Union[str, None] = ..., engine_kwargs: Union[dict[str, bool], None] = ..., numeric_only: Union[bool, lib.NoDefault] = ...): ...
    def var(self, ddof: int = ..., engine: Union[str, None] = ..., engine_kwargs: Union[dict[str, bool], None] = ..., numeric_only: Union[bool, lib.NoDefault] = ...): ...
    def sem(self, ddof: int = ..., numeric_only: Union[bool, lib.NoDefault] = ...): ...
    def size(self) -> Union[DataFrame, Series]: ...
    def sum(self, numeric_only: Union[bool, lib.NoDefault] = ..., min_count: int = ..., engine: Union[str, None] = ..., engine_kwargs: Union[dict[str, bool], None] = ...): ...
    def prod(self, numeric_only: Union[bool, lib.NoDefault] = ..., min_count: int = ...): ...
    def min(self, numeric_only: bool = ..., min_count: int = ..., engine: Union[str, None] = ..., engine_kwargs: Union[dict[str, bool], None] = ...): ...
    def max(self, numeric_only: bool = ..., min_count: int = ..., engine: Union[str, None] = ..., engine_kwargs: Union[dict[str, bool], None] = ...): ...
    def first(self, numeric_only: bool = ..., min_count: int = ...): ...
    def last(self, numeric_only: bool = ..., min_count: int = ...): ...
    def ohlc(self) -> DataFrame: ...
    def describe(self, **kwargs): ...
    def resample(self, rule, *args, **kwargs): ...
    def rolling(self, *args, **kwargs) -> RollingGroupby: ...
    def expanding(self, *args, **kwargs) -> ExpandingGroupby: ...
    def ewm(self, *args, **kwargs) -> ExponentialMovingWindowGroupby: ...
    def ffill(self, limit: Incomplete | None = ...): ...
    def pad(self, limit: Incomplete | None = ...): ...
    def bfill(self, limit: Incomplete | None = ...): ...
    def backfill(self, limit: Incomplete | None = ...): ...
    @property
    def nth(self) -> GroupByNthSelector: ...
    def quantile(self, q: float = ..., interpolation: str = ..., numeric_only: Union[bool, lib.NoDefault] = ...): ...
    def ngroup(self, ascending: bool = ...): ...
    def cumcount(self, ascending: bool = ...): ...
    def rank(self, method: str = ..., ascending: bool = ..., na_option: str = ..., pct: bool = ..., axis: int = ...) -> NDFrameT: ...
    def cumprod(self, axis: int = ..., *args, **kwargs) -> NDFrameT: ...
    def cumsum(self, axis: int = ..., *args, **kwargs) -> NDFrameT: ...
    def cummin(self, axis: int = ..., numeric_only: bool = ..., **kwargs) -> NDFrameT: ...
    def cummax(self, axis: int = ..., numeric_only: bool = ..., **kwargs) -> NDFrameT: ...
    def shift(self, periods: int = ..., freq: Incomplete | None = ..., axis: int = ..., fill_value: Incomplete | None = ...): ...
    def diff(self, periods: int = ..., axis: int = ...) -> NDFrameT: ...
    def pct_change(self, periods: int = ..., fill_method: str = ..., limit: Incomplete | None = ..., freq: Incomplete | None = ..., axis: int = ...): ...
    def head(self, n: int = ...) -> NDFrameT: ...
    def tail(self, n: int = ...) -> NDFrameT: ...
    def sample(self, n: Union[int, None] = ..., frac: Union[float, None] = ..., replace: bool = ..., weights: Union[Sequence, Series, None] = ..., random_state: Union[RandomState, None] = ...): ...

def get_groupby(obj: NDFrame, by: Union[_KeysArgType, None] = ..., axis: int = ..., level: Incomplete | None = ..., grouper: Union[ops.BaseGrouper, None] = ..., exclusions: Incomplete | None = ..., selection: Incomplete | None = ..., as_index: bool = ..., sort: bool = ..., group_keys: Union[bool, lib.NoDefault] = ..., squeeze: bool = ..., observed: bool = ..., mutated: bool = ..., dropna: bool = ...) -> GroupBy: ...
def warn_dropping_nuisance_columns_deprecated(cls, how: str, numeric_only) -> None: ...
