import numpy as np
from pandas import Index as Index
from pandas._libs import lib as lib
from pandas._libs.tslibs import NaT as NaT, OutOfBoundsDatetime as OutOfBoundsDatetime, OutOfBoundsTimedelta as OutOfBoundsTimedelta, Timedelta as Timedelta, Timestamp as Timestamp, astype_overflowsafe as astype_overflowsafe
from pandas._libs.tslibs.timedeltas import array_to_timedelta64 as array_to_timedelta64
from pandas._typing import ArrayLike as ArrayLike, Dtype as Dtype, DtypeObj as DtypeObj, Scalar as Scalar
from pandas.core.arrays import Categorical as Categorical, DatetimeArray as DatetimeArray, ExtensionArray as ExtensionArray, IntervalArray as IntervalArray, PeriodArray as PeriodArray, TimedeltaArray as TimedeltaArray
from pandas.core.dtypes.astype import astype_nansafe as astype_nansafe
from pandas.core.dtypes.common import DT64NS_DTYPE as DT64NS_DTYPE, TD64NS_DTYPE as TD64NS_DTYPE, ensure_int16 as ensure_int16, ensure_int32 as ensure_int32, ensure_int64 as ensure_int64, ensure_int8 as ensure_int8, ensure_object as ensure_object, ensure_str as ensure_str, is_bool as is_bool, is_bool_dtype as is_bool_dtype, is_complex as is_complex, is_complex_dtype as is_complex_dtype, is_datetime64_dtype as is_datetime64_dtype, is_datetime64tz_dtype as is_datetime64tz_dtype, is_dtype_equal as is_dtype_equal, is_extension_array_dtype as is_extension_array_dtype, is_float as is_float, is_float_dtype as is_float_dtype, is_integer as is_integer, is_integer_dtype as is_integer_dtype, is_numeric_dtype as is_numeric_dtype, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_string_dtype as is_string_dtype, is_timedelta64_dtype as is_timedelta64_dtype, is_unsigned_integer_dtype as is_unsigned_integer_dtype, pandas_dtype as pandas_dtype
from pandas.core.dtypes.dtypes import CategoricalDtype as CategoricalDtype, DatetimeTZDtype as DatetimeTZDtype, ExtensionDtype as ExtensionDtype, IntervalDtype as IntervalDtype, PeriodDtype as PeriodDtype
from pandas.core.dtypes.generic import ABCExtensionArray as ABCExtensionArray, ABCIndex as ABCIndex, ABCSeries as ABCSeries
from pandas.core.dtypes.inference import is_list_like as is_list_like
from pandas.core.dtypes.missing import array_equivalent as array_equivalent, is_valid_na_for_dtype as is_valid_na_for_dtype, isna as isna, na_value_for_dtype as na_value_for_dtype, notna as notna
from pandas.errors import IntCastingNaNError as IntCastingNaNError
from pandas.util._exceptions import find_stack_level as find_stack_level
from pandas.util._validators import validate_bool_kwarg as validate_bool_kwarg
from typing import Any, Sized, TypeVar, overload

NumpyArrayT = TypeVar('NumpyArrayT', bound=np.ndarray)

def maybe_convert_platform(values: Union[list, tuple, range, np.ndarray, ExtensionArray]) -> ArrayLike: ...
def is_nested_object(obj) -> bool: ...
def maybe_box_datetimelike(value: Scalar, dtype: Union[Dtype, None] = ...) -> Scalar: ...
def maybe_box_native(value: Scalar) -> Scalar: ...
@overload
def maybe_downcast_to_dtype(result: np.ndarray, dtype: Union[str, np.dtype]) -> np.ndarray: ...
@overload
def maybe_downcast_to_dtype(result: ExtensionArray, dtype: Union[str, np.dtype]) -> ArrayLike: ...
@overload
def maybe_downcast_numeric(result: np.ndarray, dtype: np.dtype, do_round: bool = ...) -> np.ndarray: ...
@overload
def maybe_downcast_numeric(result: ExtensionArray, dtype: DtypeObj, do_round: bool = ...) -> ArrayLike: ...
def maybe_cast_pointwise_result(result: ArrayLike, dtype: DtypeObj, numeric_only: bool = ..., same_dtype: bool = ...) -> ArrayLike: ...
def maybe_cast_to_extension_array(cls, obj: ArrayLike, dtype: Union[ExtensionDtype, None] = ...) -> ArrayLike: ...
@overload
def ensure_dtype_can_hold_na(dtype: np.dtype) -> np.dtype: ...
@overload
def ensure_dtype_can_hold_na(dtype: ExtensionDtype) -> ExtensionDtype: ...
def maybe_promote(dtype: np.dtype, fill_value=...): ...
def infer_dtype_from(val, pandas_dtype: bool = ...) -> tuple[DtypeObj, Any]: ...
def infer_dtype_from_scalar(val, pandas_dtype: bool = ...) -> tuple[DtypeObj, Any]: ...
def dict_compat(d: dict[Scalar, Scalar]) -> dict[Scalar, Scalar]: ...
def infer_dtype_from_array(arr, pandas_dtype: bool = ...) -> tuple[DtypeObj, ArrayLike]: ...
def maybe_upcast(values: NumpyArrayT, fill_value: Scalar = ..., copy: bool = ...) -> tuple[NumpyArrayT, Scalar]: ...
def invalidate_string_dtypes(dtype_set: set[DtypeObj]) -> None: ...
def coerce_indexer_dtype(indexer, categories) -> np.ndarray: ...
def soft_convert_objects(values: np.ndarray, datetime: bool = ..., numeric: bool = ..., timedelta: bool = ..., period: bool = ..., copy: bool = ...) -> ArrayLike: ...
def convert_dtypes(input_array: ArrayLike, convert_string: bool = ..., convert_integer: bool = ..., convert_boolean: bool = ..., convert_floating: bool = ...) -> DtypeObj: ...
def maybe_infer_to_datetimelike(value: np.ndarray) -> Union[np.ndarray, DatetimeArray, TimedeltaArray, PeriodArray, IntervalArray]: ...
def maybe_cast_to_datetime(value: Union[ExtensionArray, np.ndarray, list], dtype: Union[DtypeObj, None]) -> Union[ExtensionArray, np.ndarray]: ...
def sanitize_to_nanoseconds(values: np.ndarray, copy: bool = ...) -> np.ndarray: ...
def find_result_type(left: ArrayLike, right: Any) -> DtypeObj: ...
def common_dtype_categorical_compat(objs: list[Union[Index, ArrayLike]], dtype: DtypeObj) -> DtypeObj: ...
@overload
def find_common_type(types: list[np.dtype]) -> np.dtype: ...
@overload
def find_common_type(types: list[ExtensionDtype]) -> DtypeObj: ...
@overload
def find_common_type(types: list[DtypeObj]) -> DtypeObj: ...
def construct_2d_arraylike_from_scalar(value: Scalar, length: int, width: int, dtype: np.dtype, copy: bool) -> np.ndarray: ...
def construct_1d_arraylike_from_scalar(value: Scalar, length: int, dtype: Union[DtypeObj, None]) -> ArrayLike: ...
def construct_1d_object_array_from_listlike(values: Sized) -> np.ndarray: ...
def maybe_cast_to_integer_array(arr: Union[list, np.ndarray], dtype: np.dtype, copy: bool = ...) -> np.ndarray: ...
def can_hold_element(arr: ArrayLike, element: Any) -> bool: ...
def np_can_hold_element(dtype: np.dtype, element: Any) -> Any: ...

class LossySetitemError(Exception): ...
