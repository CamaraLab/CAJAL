import numpy as np
from _typeshed import Incomplete
from pandas._config import get_option as get_option
from pandas._libs import lib as lib
from pandas._libs.tslibs import NaT as NaT, Period as Period, iNaT as iNaT
from pandas._typing import ArrayLike as ArrayLike, DtypeObj as DtypeObj, NDFrame as NDFrame, NDFrameT as NDFrameT, Scalar as Scalar, npt as npt
from pandas.core.dtypes.common import DT64NS_DTYPE as DT64NS_DTYPE, TD64NS_DTYPE as TD64NS_DTYPE, ensure_object as ensure_object, is_bool_dtype as is_bool_dtype, is_categorical_dtype as is_categorical_dtype, is_complex_dtype as is_complex_dtype, is_datetimelike_v_numeric as is_datetimelike_v_numeric, is_dtype_equal as is_dtype_equal, is_extension_array_dtype as is_extension_array_dtype, is_float_dtype as is_float_dtype, is_integer_dtype as is_integer_dtype, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_string_or_object_np_dtype as is_string_or_object_np_dtype, needs_i8_conversion as needs_i8_conversion
from pandas.core.dtypes.dtypes import CategoricalDtype as CategoricalDtype, DatetimeTZDtype as DatetimeTZDtype, ExtensionDtype as ExtensionDtype, IntervalDtype as IntervalDtype, PeriodDtype as PeriodDtype
from pandas.core.dtypes.generic import ABCDataFrame as ABCDataFrame, ABCExtensionArray as ABCExtensionArray, ABCIndex as ABCIndex, ABCMultiIndex as ABCMultiIndex, ABCSeries as ABCSeries
from pandas.core.dtypes.inference import is_list_like as is_list_like
from pandas.core.indexes.base import Index as Index
from typing import overload

isposinf_scalar: Incomplete
isneginf_scalar: Incomplete
nan_checker: Incomplete
INF_AS_NA: bool


@overload
def isna(obj: Scalar) -> bool: ...
@overload
def isna(obj: Union[ArrayLike, Index, list]) -> npt.NDArray[np.bool_]: ...
@overload
def isna(obj: NDFrameT) -> NDFrameT: ...
@overload
def isna(obj: Union[NDFrameT, ArrayLike, Index, list]) -> Union[NDFrameT, npt.NDArray[np.bool_]]: ...
@overload
def isna(obj: object) -> Union[bool, npt.NDArray[np.bool_], NDFrame]: ...
isnull = isna


@overload
def notna(obj: Scalar) -> bool: ...
@overload
def notna(obj: Union[ArrayLike, Index, list]) -> npt.NDArray[np.bool_]: ...
@overload
def notna(obj: NDFrameT) -> NDFrameT: ...
@overload
def notna(obj: Union[NDFrameT, ArrayLike, Index, list]) -> Union[NDFrameT, npt.NDArray[np.bool_]]: ...
@overload
def notna(obj: object) -> Union[bool, npt.NDArray[np.bool_], NDFrame]: ...
notnull = notna

def isna_compat(arr, fill_value=...) -> bool: ...
def array_equivalent(left, right, strict_nan: bool = ..., dtype_equal: bool = ...) -> bool: ...
def array_equals(left: ArrayLike, right: ArrayLike) -> bool: ...
def infer_fill_value(val): ...
def maybe_fill(arr: np.ndarray) -> np.ndarray: ...
def na_value_for_dtype(dtype: DtypeObj, compat: bool = ...): ...
def remove_na_arraylike(arr): ...
def is_valid_na_for_dtype(obj, dtype: DtypeObj) -> bool: ...
def isna_all(arr: ArrayLike) -> bool: ...
