import numpy as np
from _typeshed import Incomplete
from pandas._typing import ArrayLike, DtypeObj
from pandas.core.dtypes.inference import is_array_like as is_array_like, is_bool as is_bool, is_complex as is_complex, is_dataclass as is_dataclass, is_decimal as is_decimal, is_dict_like as is_dict_like, is_file_like as is_file_like, is_interval as is_interval, is_iterator as is_iterator, is_named_tuple as is_named_tuple, is_nested_list_like as is_nested_list_like, is_number as is_number, is_re as is_re, is_re_compilable as is_re_compilable, is_sequence as is_sequence
from typing import Any, Callable

DT64NS_DTYPE: Incomplete
TD64NS_DTYPE: Incomplete
INT64_DTYPE: Incomplete
ensure_float64: Incomplete

def ensure_float(arr): ...
def ensure_str(value: Union[bytes, Any]) -> str: ...
def ensure_python_int(value: Union[int, np.integer]) -> int: ...
def classes(*klasses) -> Callable: ...
def classes_and_not_datetimelike(*klasses) -> Callable: ...
def is_object_dtype(arr_or_dtype) -> bool: ...
def is_sparse(arr) -> bool: ...
def is_scipy_sparse(arr) -> bool: ...
def is_categorical(arr) -> bool: ...
def is_datetime64_dtype(arr_or_dtype) -> bool: ...
def is_datetime64tz_dtype(arr_or_dtype) -> bool: ...
def is_timedelta64_dtype(arr_or_dtype) -> bool: ...
def is_period_dtype(arr_or_dtype) -> bool: ...
def is_interval_dtype(arr_or_dtype) -> bool: ...
def is_categorical_dtype(arr_or_dtype) -> bool: ...
def is_string_or_object_np_dtype(dtype: np.dtype) -> bool: ...
def is_string_dtype(arr_or_dtype) -> bool: ...
def is_dtype_equal(source, target) -> bool: ...
def is_any_int_dtype(arr_or_dtype) -> bool: ...
def is_integer_dtype(arr_or_dtype) -> bool: ...
def is_signed_integer_dtype(arr_or_dtype) -> bool: ...
def is_unsigned_integer_dtype(arr_or_dtype) -> bool: ...
def is_int64_dtype(arr_or_dtype) -> bool: ...
def is_datetime64_any_dtype(arr_or_dtype) -> bool: ...
def is_datetime64_ns_dtype(arr_or_dtype) -> bool: ...
def is_timedelta64_ns_dtype(arr_or_dtype) -> bool: ...
def is_datetime_or_timedelta_dtype(arr_or_dtype) -> bool: ...
def is_numeric_v_string_like(a: ArrayLike, b) -> bool: ...
def is_datetimelike_v_numeric(a, b) -> bool: ...
def needs_i8_conversion(arr_or_dtype) -> bool: ...
def is_numeric_dtype(arr_or_dtype) -> bool: ...
def is_float_dtype(arr_or_dtype) -> bool: ...
def is_bool_dtype(arr_or_dtype) -> bool: ...
def is_extension_type(arr) -> bool: ...
def is_1d_only_ea_obj(obj: Any) -> bool: ...
def is_1d_only_ea_dtype(dtype: Union[DtypeObj, None]) -> bool: ...
def is_extension_array_dtype(arr_or_dtype) -> bool: ...
def is_ea_or_datetimelike_dtype(dtype: Union[DtypeObj, None]) -> bool: ...
def is_complex_dtype(arr_or_dtype) -> bool: ...
def get_dtype(arr_or_dtype) -> DtypeObj: ...
def infer_dtype_from_object(dtype) -> type: ...
def validate_all_hashable(*args, error_name: Union[str, None] = ...) -> None: ...
def pandas_dtype(dtype) -> DtypeObj: ...
def is_all_strings(value: ArrayLike) -> bool: ...
