import numpy as np
from _typeshed import Incomplete
from pandas import Categorical as Categorical, DataFrame as DataFrame, Index as Index, MultiIndex as MultiIndex, Series as Series
from pandas._libs import algos as algos, iNaT as iNaT, lib as lib
from pandas._typing import AnyArrayLike as AnyArrayLike, ArrayLike as ArrayLike, DtypeObj as DtypeObj, IndexLabel as IndexLabel, NumpySorter as NumpySorter, NumpyValueArrayLike as NumpyValueArrayLike, TakeIndexer as TakeIndexer, npt as npt
from pandas.core.array_algos.take import take_nd as take_nd
from pandas.core.arrays import BaseMaskedArray as BaseMaskedArray, ExtensionArray as ExtensionArray
from pandas.core.construction import ensure_wrapped_if_datetimelike as ensure_wrapped_if_datetimelike, extract_array as extract_array
from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike as construct_1d_object_array_from_listlike, infer_dtype_from_array as infer_dtype_from_array, sanitize_to_nanoseconds as sanitize_to_nanoseconds
from pandas.core.dtypes.common import ensure_float64 as ensure_float64, ensure_object as ensure_object, ensure_platform_int as ensure_platform_int, is_array_like as is_array_like, is_bool_dtype as is_bool_dtype, is_categorical_dtype as is_categorical_dtype, is_complex_dtype as is_complex_dtype, is_datetime64_dtype as is_datetime64_dtype, is_extension_array_dtype as is_extension_array_dtype, is_float_dtype as is_float_dtype, is_integer as is_integer, is_integer_dtype as is_integer_dtype, is_list_like as is_list_like, is_numeric_dtype as is_numeric_dtype, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_signed_integer_dtype as is_signed_integer_dtype, is_timedelta64_dtype as is_timedelta64_dtype, needs_i8_conversion as needs_i8_conversion
from pandas.core.dtypes.concat import concat_compat as concat_compat
from pandas.core.dtypes.dtypes import BaseMaskedDtype as BaseMaskedDtype, ExtensionDtype as ExtensionDtype, PandasDtype as PandasDtype
from pandas.core.dtypes.generic import ABCDatetimeArray as ABCDatetimeArray, ABCExtensionArray as ABCExtensionArray, ABCIndex as ABCIndex, ABCMultiIndex as ABCMultiIndex, ABCRangeIndex as ABCRangeIndex, ABCSeries as ABCSeries, ABCTimedeltaArray as ABCTimedeltaArray
from pandas.core.dtypes.missing import isna as isna, na_value_for_dtype as na_value_for_dtype
from pandas.core.indexers import validate_indices as validate_indices
from pandas.util._decorators import doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Literal

def unique(values): ...
def unique_with_mask(values, mask: Union[npt.NDArray[np.bool_], None] = ...): ...
unique1d = unique

def isin(comps: AnyArrayLike, values: AnyArrayLike) -> npt.NDArray[np.bool_]: ...
def factorize_array(values: np.ndarray, na_sentinel: Union[int, None] = ..., size_hint: Union[int, None] = ..., na_value: object = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> tuple[npt.NDArray[np.intp], np.ndarray]: ...
def factorize(values, sort: bool = ..., na_sentinel: Union[int, None, lib.NoDefault] = ..., use_na_sentinel: Union[bool, lib.NoDefault] = ..., size_hint: Union[int, None] = ...) -> tuple[np.ndarray, Union[np.ndarray, Index]]: ...
def resolve_na_sentinel(na_sentinel: Union[int, None, lib.NoDefault], use_na_sentinel: Union[bool, lib.NoDefault]) -> Union[int, None]: ...
def value_counts(values, sort: bool = ..., ascending: bool = ..., normalize: bool = ..., bins: Incomplete | None = ..., dropna: bool = ...) -> Series: ...
def value_counts_arraylike(values: np.ndarray, dropna: bool, mask: Union[npt.NDArray[np.bool_], None] = ...) -> tuple[ArrayLike, npt.NDArray[np.int64]]: ...
def duplicated(values: ArrayLike, keep: Literal['first', 'last', False] = ...) -> npt.NDArray[np.bool_]: ...
def mode(values: ArrayLike, dropna: bool = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> ArrayLike: ...
def rank(values: ArrayLike, axis: int = ..., method: str = ..., na_option: str = ..., ascending: bool = ..., pct: bool = ...) -> npt.NDArray[np.float64]: ...
def checked_add_with_arr(arr: npt.NDArray[np.int64], b: Union[int, npt.NDArray[np.int64]], arr_mask: Union[npt.NDArray[np.bool_], None] = ..., b_mask: Union[npt.NDArray[np.bool_], None] = ...) -> npt.NDArray[np.int64]: ...

class SelectN:
    obj: Incomplete
    n: Incomplete
    keep: Incomplete
    def __init__(self, obj, n: int, keep: str) -> None: ...
    def compute(self, method: str) -> Union[DataFrame, Series]: ...
    def nlargest(self): ...
    def nsmallest(self): ...
    @staticmethod
    def is_valid_dtype_n_method(dtype: DtypeObj) -> bool: ...

class SelectNSeries(SelectN):
    def compute(self, method: str) -> Series: ...

class SelectNFrame(SelectN):
    columns: Incomplete
    def __init__(self, obj: DataFrame, n: int, keep: str, columns: IndexLabel) -> None: ...
    def compute(self, method: str) -> DataFrame: ...

def take(arr, indices: TakeIndexer, axis: int = ..., allow_fill: bool = ..., fill_value: Incomplete | None = ...): ...
def searchsorted(arr: ArrayLike, value: Union[NumpyValueArrayLike, ExtensionArray], side: Literal['left', 'right'] = ..., sorter: NumpySorter = ...) -> Union[npt.NDArray[np.intp], np.intp]: ...
def diff(arr, n: int, axis: int = ...): ...
def safe_sort(values, codes: Incomplete | None = ..., na_sentinel: int = ..., assume_unique: bool = ..., verify: bool = ...) -> Union[np.ndarray, MultiIndex, tuple[Union[np.ndarray, MultiIndex], np.ndarray]]: ...
def union_with_duplicates(lvals: ArrayLike, rvals: ArrayLike) -> ArrayLike: ...
