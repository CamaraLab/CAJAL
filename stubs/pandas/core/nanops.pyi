import numpy as np
from _typeshed import Incomplete
from pandas._config import get_option as get_option
from pandas._libs import NaT as NaT, NaTType as NaTType, iNaT as iNaT, lib as lib
from pandas._typing import ArrayLike as ArrayLike, Dtype as Dtype, DtypeObj as DtypeObj, F as F, Scalar as Scalar, Shape as Shape, npt as npt
from pandas.compat._optional import import_optional_dependency as import_optional_dependency
from pandas.core.construction import extract_array as extract_array
from pandas.core.dtypes.common import is_any_int_dtype as is_any_int_dtype, is_bool_dtype as is_bool_dtype, is_complex as is_complex, is_datetime64_any_dtype as is_datetime64_any_dtype, is_float as is_float, is_float_dtype as is_float_dtype, is_integer as is_integer, is_integer_dtype as is_integer_dtype, is_numeric_dtype as is_numeric_dtype, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_timedelta64_dtype as is_timedelta64_dtype, needs_i8_conversion as needs_i8_conversion, pandas_dtype as pandas_dtype
from pandas.core.dtypes.dtypes import PeriodDtype as PeriodDtype
from pandas.core.dtypes.missing import isna as isna, na_value_for_dtype as na_value_for_dtype, notna as notna
from typing import Any, Callable

bn: Incomplete

def set_use_bottleneck(v: bool = ...) -> None: ...

class disallow:
    dtypes: Incomplete
    def __init__(self, *dtypes: Dtype) -> None: ...
    def check(self, obj) -> bool: ...
    def __call__(self, f: F) -> F: ...

class bottleneck_switch:
    name: Incomplete
    kwargs: Incomplete
    def __init__(self, name: Incomplete | None = ..., **kwargs) -> None: ...
    def __call__(self, alt: F) -> F: ...

def maybe_operate_rowwise(func: F) -> F: ...
def nanany(values: np.ndarray, *, axis: Union[int, None] = ..., skipna: bool = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> bool: ...
def nanall(values: np.ndarray, *, axis: Union[int, None] = ..., skipna: bool = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> bool: ...
def nansum(values: np.ndarray, *, axis: Union[int, None] = ..., skipna: bool = ..., min_count: int = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> float: ...
def nanmean(values: np.ndarray, *, axis: Union[int, None] = ..., skipna: bool = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> float: ...
def nanmedian(values, *, axis: Incomplete | None = ..., skipna: bool = ..., mask: Incomplete | None = ...): ...
def get_empty_reduction_result(shape: tuple[int, ...], axis: int, dtype: Union[np.dtype, type[np.floating]], fill_value: Any) -> np.ndarray: ...
def nanstd(values, *, axis: Incomplete | None = ..., skipna: bool = ..., ddof: int = ..., mask: Incomplete | None = ...): ...
def nanvar(values, *, axis: Incomplete | None = ..., skipna: bool = ..., ddof: int = ..., mask: Incomplete | None = ...): ...
def nansem(values: np.ndarray, *, axis: Union[int, None] = ..., skipna: bool = ..., ddof: int = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> float: ...

nanmin: Incomplete
nanmax: Incomplete

def nanargmax(values: np.ndarray, *, axis: Union[int, None] = ..., skipna: bool = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> Union[int, np.ndarray]: ...
def nanargmin(values: np.ndarray, *, axis: Union[int, None] = ..., skipna: bool = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> Union[int, np.ndarray]: ...
def nanskew(values: np.ndarray, *, axis: Union[int, None] = ..., skipna: bool = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> float: ...
def nankurt(values: np.ndarray, *, axis: Union[int, None] = ..., skipna: bool = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> float: ...
def nanprod(values: np.ndarray, *, axis: Union[int, None] = ..., skipna: bool = ..., min_count: int = ..., mask: Union[npt.NDArray[np.bool_], None] = ...) -> float: ...
def check_below_min_count(shape: tuple[int, ...], mask: Union[npt.NDArray[np.bool_], None], min_count: int) -> bool: ...
def nancorr(a: np.ndarray, b: np.ndarray, *, method: str = ..., min_periods: Union[int, None] = ...) -> float: ...
def get_corr_func(method) -> Callable[[np.ndarray, np.ndarray], float]: ...
def nancov(a: np.ndarray, b: np.ndarray, *, min_periods: Union[int, None] = ..., ddof: Union[int, None] = ...) -> float: ...
def make_nancomp(op): ...

nangt: Incomplete
nange: Incomplete
nanlt: Incomplete
nanle: Incomplete
naneq: Incomplete
nanne: Incomplete

def na_accum_func(values: ArrayLike, accum_func, *, skipna: bool) -> ArrayLike: ...
