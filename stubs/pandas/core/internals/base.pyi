from _typeshed import Incomplete
from pandas._typing import ArrayLike as ArrayLike, DtypeObj as DtypeObj, Shape as Shape
from pandas.core.base import PandasObject as PandasObject
from pandas.core.dtypes.cast import find_common_type as find_common_type, np_can_hold_element as np_can_hold_element
from pandas.core.indexes.api import Index as Index, default_index as default_index
from pandas.errors import AbstractMethodError as AbstractMethodError
from typing import Literal, TypeVar

T = TypeVar('T', bound='DataManager')

class DataManager(PandasObject):
    axes: list[Index]
    @property
    def items(self) -> Index: ...
    def __len__(self) -> int: ...
    @property
    def ndim(self) -> int: ...
    @property
    def shape(self) -> Shape: ...
    def reindex_indexer(self, new_axis, indexer, axis: int, fill_value: Incomplete | None = ..., allow_dups: bool = ..., copy: bool = ..., only_slice: bool = ...) -> T: ...
    def reindex_axis(self, new_index: Index, axis: int, fill_value: Incomplete | None = ..., only_slice: bool = ...) -> T: ...
    def equals(self, other: object) -> bool: ...
    def apply(self, f, align_keys: Union[list[str], None] = ..., ignore_failures: bool = ..., **kwargs) -> T: ...
    def isna(self, func) -> T: ...
    def is_consolidated(self) -> bool: ...
    def consolidate(self) -> T: ...

class SingleDataManager(DataManager):
    @property
    def ndim(self) -> Literal[1]: ...
    @property
    def array(self) -> ArrayLike: ...
    def setitem_inplace(self, indexer, value) -> None: ...
    def grouped_reduce(self, func, ignore_failures: bool = ...): ...
    @classmethod
    def from_array(cls, arr: ArrayLike, index: Index): ...

def interleaved_dtype(dtypes: list[DtypeObj]) -> Union[DtypeObj, None]: ...
