import numpy as np
from _typeshed import Incomplete
from pandas import Index as Index
from pandas._libs import lib as lib
from pandas._libs.algos import unique_deltas as unique_deltas
from pandas._libs.lib import no_default as no_default
from pandas._typing import Dtype as Dtype, npt as npt
from pandas.core import ops as ops
from pandas.core.algorithms import resolve_na_sentinel as resolve_na_sentinel
from pandas.core.construction import extract_array as extract_array
from pandas.core.dtypes.common import ensure_platform_int as ensure_platform_int, ensure_python_int as ensure_python_int, is_float as is_float, is_integer as is_integer, is_scalar as is_scalar, is_signed_integer_dtype as is_signed_integer_dtype, is_timedelta64_dtype as is_timedelta64_dtype
from pandas.core.dtypes.generic import ABCTimedeltaIndex as ABCTimedeltaIndex
from pandas.core.indexes.base import maybe_extract_name as maybe_extract_name
from pandas.core.indexes.numeric import Float64Index as Float64Index, Int64Index as Int64Index, NumericIndex as NumericIndex
from pandas.core.ops.common import unpack_zerodim_and_defer as unpack_zerodim_and_defer
from pandas.util._decorators import cache_readonly as cache_readonly, doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Any, Callable, Hashable, Iterator

class RangeIndex(NumericIndex):
    def __new__(cls, start: Incomplete | None = ..., stop: Incomplete | None = ..., step: Incomplete | None = ..., dtype: Union[Dtype, None] = ..., copy: bool = ..., name: Hashable = ...) -> RangeIndex: ...
    @classmethod
    def from_range(cls, data: range, name: Incomplete | None = ..., dtype: Union[Dtype, None] = ...) -> RangeIndex: ...
    def __reduce__(self): ...
    @property
    def start(self) -> int: ...
    @property
    def stop(self) -> int: ...
    @property
    def step(self) -> int: ...
    def nbytes(self) -> int: ...
    def memory_usage(self, deep: bool = ...) -> int: ...
    @property
    def dtype(self) -> np.dtype: ...
    @property
    def is_unique(self) -> bool: ...
    def is_monotonic_increasing(self) -> bool: ...
    def is_monotonic_decreasing(self) -> bool: ...
    def __contains__(self, key: Any) -> bool: ...
    @property
    def inferred_type(self) -> str: ...
    def get_loc(self, key, method: Incomplete | None = ..., tolerance: Incomplete | None = ...): ...
    def tolist(self) -> list[int]: ...
    def __iter__(self) -> Iterator[int]: ...
    def copy(self, name: Hashable = ..., deep: bool = ..., dtype: Union[Dtype, None] = ..., names: Incomplete | None = ...): ...
    def min(self, axis: Incomplete | None = ..., skipna: bool = ..., *args, **kwargs) -> int: ...
    def max(self, axis: Incomplete | None = ..., skipna: bool = ..., *args, **kwargs) -> int: ...
    def argsort(self, *args, **kwargs) -> npt.NDArray[np.intp]: ...
    def factorize(self, sort: bool = ..., na_sentinel: Union[int, lib.NoDefault] = ..., use_na_sentinel: Union[bool, lib.NoDefault] = ...) -> tuple[npt.NDArray[np.intp], RangeIndex]: ...
    def equals(self, other: object) -> bool: ...
    def sort_values(self, return_indexer: bool = ..., ascending: bool = ..., na_position: str = ..., key: Union[Callable, None] = ...): ...
    def symmetric_difference(self, other, result_name: Hashable = ..., sort: Incomplete | None = ...): ...
    def delete(self, loc) -> Index: ...
    def insert(self, loc: int, item) -> Index: ...
    def __len__(self) -> int: ...
    @property
    def size(self) -> int: ...
    def __getitem__(self, key): ...
    def __floordiv__(self, other): ...
    def all(self, *args, **kwargs) -> bool: ...
    def any(self, *args, **kwargs) -> bool: ...
