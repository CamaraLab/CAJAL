import numpy as np
from _typeshed import Incomplete
from pandas import Index as Index
from pandas._libs import algos as algos, lib as lib
from pandas._typing import ArrayLike as ArrayLike, Axis as Axis, F as F, npt as npt
from pandas.compat._optional import import_optional_dependency as import_optional_dependency
from pandas.core.dtypes.cast import infer_dtype_from as infer_dtype_from
from pandas.core.dtypes.common import is_array_like as is_array_like, is_numeric_v_string_like as is_numeric_v_string_like, needs_i8_conversion as needs_i8_conversion
from pandas.core.dtypes.missing import is_valid_na_for_dtype as is_valid_na_for_dtype, isna as isna, na_value_for_dtype as na_value_for_dtype
from typing import Any

def check_value_size(value, mask: npt.NDArray[np.bool_], length: int): ...
def mask_missing(arr: ArrayLike, values_to_mask) -> npt.NDArray[np.bool_]: ...
def clean_fill_method(method: Union[str, None], allow_nearest: bool = ...): ...

NP_METHODS: Incomplete
SP_METHODS: Incomplete

def clean_interp_method(method: str, index: Index, **kwargs) -> str: ...
def find_valid_index(values, *, how: str) -> Union[int, None]: ...
def interpolate_array_2d(data: np.ndarray, method: str = ..., axis: int = ..., index: Union[Index, None] = ..., limit: Union[int, None] = ..., limit_direction: str = ..., limit_area: Union[str, None] = ..., fill_value: Union[Any, None] = ..., coerce: bool = ..., downcast: Union[str, None] = ..., **kwargs) -> None: ...
def interpolate_2d(values: np.ndarray, method: str = ..., axis: Axis = ..., limit: Union[int, None] = ..., limit_area: Union[str, None] = ...) -> None: ...
def get_fill_func(method, ndim: int = ...): ...
def clean_reindex_fill_method(method) -> Union[str, None]: ...
