import numpy as np
from _typeshed import Incomplete
from pandas import DataFrame as DataFrame, Series as Series
from pandas._libs.indexing import NDFrameIndexerBase as NDFrameIndexerBase
from pandas._libs.lib import item_from_zerodim as item_from_zerodim
from pandas.core.construction import extract_array as extract_array
from pandas.core.dtypes.cast import can_hold_element as can_hold_element, maybe_promote as maybe_promote
from pandas.core.dtypes.common import is_array_like as is_array_like, is_bool_dtype as is_bool_dtype, is_extension_array_dtype as is_extension_array_dtype, is_hashable as is_hashable, is_integer as is_integer, is_iterator as is_iterator, is_list_like as is_list_like, is_numeric_dtype as is_numeric_dtype, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_sequence as is_sequence
from pandas.core.dtypes.concat import concat_compat as concat_compat
from pandas.core.dtypes.generic import ABCDataFrame as ABCDataFrame, ABCSeries as ABCSeries
from pandas.core.dtypes.missing import infer_fill_value as infer_fill_value, is_valid_na_for_dtype as is_valid_na_for_dtype, isna as isna, na_value_for_dtype as na_value_for_dtype
from pandas.core.indexers import check_array_indexer as check_array_indexer, is_empty_indexer as is_empty_indexer, is_list_like_indexer as is_list_like_indexer, is_scalar_indexer as is_scalar_indexer, length_of_indexer as length_of_indexer
from pandas.core.indexes.api import Index as Index, MultiIndex as MultiIndex
from pandas.errors import AbstractMethodError as AbstractMethodError, IndexingError as IndexingError, InvalidIndexError as InvalidIndexError
from pandas.util._decorators import doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level

class _IndexSlice:
    def __getitem__(self, arg): ...

IndexSlice: Incomplete

class IndexingMixin:
    @property
    def iloc(self) -> _iLocIndexer: ...
    @property
    def loc(self) -> _LocIndexer: ...
    @property
    def at(self) -> _AtIndexer: ...
    @property
    def iat(self) -> _iAtIndexer: ...

class _LocationIndexer(NDFrameIndexerBase):
    axis: Union[int, None]
    def __call__(self, axis: Incomplete | None = ...) -> _LocationIndexerT: ...
    def __setitem__(self, key, value) -> None: ...
    def __getitem__(self, key): ...

class _LocIndexer(_LocationIndexer): ...
class _iLocIndexer(_LocationIndexer): ...

class _ScalarAccessIndexer(NDFrameIndexerBase):
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...

class _AtIndexer(_ScalarAccessIndexer):
    def __getitem__(self, key): ...
    def __setitem__(self, key, value): ...

class _iAtIndexer(_ScalarAccessIndexer): ...

def convert_to_index_sliceable(obj: DataFrame, key): ...
def check_bool_indexer(index: Index, key) -> np.ndarray: ...
def convert_missing_indexer(indexer): ...
def convert_from_missing_indexer_tuple(indexer, axes): ...
def maybe_convert_ix(*args): ...
def is_nested_tuple(tup, labels) -> bool: ...
def is_label_like(key) -> bool: ...
def need_slice(obj: slice) -> bool: ...
def check_deprecated_indexers(key) -> None: ...
