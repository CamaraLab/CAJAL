import numpy as np
import pyarrow as pa
from _typeshed import Incomplete
from pandas import Series as Series
from pandas._libs import lib as lib
from pandas._typing import Dtype as Dtype, PositionalIndexer as PositionalIndexer, TakeIndexer as TakeIndexer, npt as npt
from pandas.compat import pa_version_under1p01 as pa_version_under1p01, pa_version_under2p0 as pa_version_under2p0, pa_version_under3p0 as pa_version_under3p0, pa_version_under4p0 as pa_version_under4p0, pa_version_under5p0 as pa_version_under5p0, pa_version_under6p0 as pa_version_under6p0, pa_version_under7p0 as pa_version_under7p0
from pandas.core.algorithms import resolve_na_sentinel as resolve_na_sentinel
from pandas.core.arraylike import OpsMixin as OpsMixin
from pandas.core.arrays.arrow._arrow_utils import fallback_performancewarning as fallback_performancewarning
from pandas.core.arrays.arrow.dtype import ArrowDtype as ArrowDtype
from pandas.core.arrays.base import ExtensionArray as ExtensionArray
from pandas.core.dtypes.common import is_array_like as is_array_like, is_bool_dtype as is_bool_dtype, is_integer as is_integer, is_integer_dtype as is_integer_dtype, is_scalar as is_scalar
from pandas.core.dtypes.missing import isna as isna
from pandas.core.indexers import check_array_indexer as check_array_indexer, unpack_tuple_and_ellipses as unpack_tuple_and_ellipses, validate_indices as validate_indices
from pandas.util._decorators import deprecate_nonkeyword_arguments as deprecate_nonkeyword_arguments, doc as doc
from typing import Any, TypeVar

ARROW_CMP_FUNCS: Incomplete
ARROW_LOGICAL_FUNCS: Incomplete

def cast_for_truediv(arrow_array: pa.ChunkedArray, pa_object: Union[pa.Array, pa.Scalar]) -> pa.ChunkedArray: ...
def floordiv_compat(left: Union[pa.ChunkedArray, pa.Array, pa.Scalar], right: Union[pa.ChunkedArray, pa.Array, pa.Scalar]) -> pa.ChunkedArray: ...

ARROW_ARITHMETIC_FUNCS: Incomplete
ArrowExtensionArrayT = TypeVar('ArrowExtensionArrayT', bound='ArrowExtensionArray')

def to_pyarrow_type(dtype: Union[ArrowDtype, pa.DataType, Dtype, None]) -> Union[pa.DataType, None]: ...

class ArrowExtensionArray(OpsMixin, ExtensionArray):
    def __init__(self, values: Union[pa.Array, pa.ChunkedArray]) -> None: ...
    def __getitem__(self, item: PositionalIndexer): ...
    def __arrow_array__(self, type: Incomplete | None = ...): ...
    def __invert__(self) -> ArrowExtensionArrayT: ...
    def __neg__(self) -> ArrowExtensionArrayT: ...
    def __pos__(self) -> ArrowExtensionArrayT: ...
    def __abs__(self) -> ArrowExtensionArrayT: ...
    def equals(self, other) -> bool: ...
    @property
    def dtype(self) -> ArrowDtype: ...
    @property
    def nbytes(self) -> int: ...
    def __len__(self) -> int: ...
    def isna(self) -> npt.NDArray[np.bool_]: ...
    def argsort(self, ascending: bool = ..., kind: str = ..., na_position: str = ..., *args, **kwargs) -> np.ndarray: ...
    def argmin(self, skipna: bool = ...) -> int: ...
    def argmax(self, skipna: bool = ...) -> int: ...
    def copy(self) -> ArrowExtensionArrayT: ...
    def dropna(self) -> ArrowExtensionArrayT: ...
    def isin(self, values) -> npt.NDArray[np.bool_]: ...
    def factorize(self, na_sentinel: Union[int, lib.NoDefault] = ..., use_na_sentinel: Union[bool, lib.NoDefault] = ...) -> tuple[np.ndarray, ExtensionArray]: ...
    def reshape(self, *args, **kwargs) -> None: ...
    def take(self, indices: TakeIndexer, allow_fill: bool = ..., fill_value: Any = ...) -> ArrowExtensionArray: ...
    def unique(self) -> ArrowExtensionArrayT: ...
    def value_counts(self, dropna: bool = ...) -> Series: ...
    def __setitem__(self, key: Union[int, slice, np.ndarray], value: Any) -> None: ...
