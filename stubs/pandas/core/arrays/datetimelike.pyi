import numpy as np
from _typeshed import Incomplete
from pandas._libs import algos as algos, lib as lib
from pandas._libs.arrays import NDArrayBacked as NDArrayBacked
from pandas._libs.tslibs import BaseOffset as BaseOffset, IncompatibleFrequency as IncompatibleFrequency, NaT as NaT, NaTType as NaTType, Period as Period, Resolution as Resolution, Tick as Tick, Timestamp as Timestamp, delta_to_nanoseconds as delta_to_nanoseconds, get_unit_from_dtype as get_unit_from_dtype, iNaT as iNaT, ints_to_pydatetime as ints_to_pydatetime, ints_to_pytimedelta as ints_to_pytimedelta, to_offset as to_offset
from pandas._libs.tslibs.fields import RoundTo as RoundTo, round_nsint64 as round_nsint64
from pandas._libs.tslibs.np_datetime import compare_mismatched_resolutions as compare_mismatched_resolutions
from pandas._libs.tslibs.timestamps import integer_op_not_supported as integer_op_not_supported
from pandas._typing import ArrayLike as ArrayLike, DatetimeLikeScalar as DatetimeLikeScalar, Dtype as Dtype, DtypeObj as DtypeObj, NpDtype as NpDtype, PositionalIndexer2D as PositionalIndexer2D, PositionalIndexerTuple as PositionalIndexerTuple, ScalarIndexer as ScalarIndexer, SequenceIndexer as SequenceIndexer, npt as npt
from pandas.core import nanops as nanops, ops as ops
from pandas.core.algorithms import checked_add_with_arr as checked_add_with_arr, isin as isin, mode as mode, unique1d as unique1d
from pandas.core.arraylike import OpsMixin as OpsMixin
from pandas.core.arrays import DatetimeArray as DatetimeArray, PeriodArray as PeriodArray, TimedeltaArray as TimedeltaArray
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray as NDArrayBackedExtensionArray, ravel_compat as ravel_compat
from pandas.core.arrays.base import ExtensionArray as ExtensionArray
from pandas.core.arrays.integer import IntegerArray as IntegerArray
from pandas.core.construction import ensure_wrapped_if_datetimelike as ensure_wrapped_if_datetimelike, extract_array as extract_array
from pandas.core.dtypes.common import is_all_strings as is_all_strings, is_categorical_dtype as is_categorical_dtype, is_datetime64_any_dtype as is_datetime64_any_dtype, is_datetime64_dtype as is_datetime64_dtype, is_datetime64tz_dtype as is_datetime64tz_dtype, is_datetime_or_timedelta_dtype as is_datetime_or_timedelta_dtype, is_dtype_equal as is_dtype_equal, is_float_dtype as is_float_dtype, is_integer_dtype as is_integer_dtype, is_list_like as is_list_like, is_object_dtype as is_object_dtype, is_period_dtype as is_period_dtype, is_string_dtype as is_string_dtype, is_timedelta64_dtype as is_timedelta64_dtype, is_unsigned_integer_dtype as is_unsigned_integer_dtype, pandas_dtype as pandas_dtype
from pandas.core.dtypes.dtypes import DatetimeTZDtype as DatetimeTZDtype, ExtensionDtype as ExtensionDtype
from pandas.core.dtypes.generic import ABCCategorical as ABCCategorical, ABCMultiIndex as ABCMultiIndex
from pandas.core.dtypes.missing import is_valid_na_for_dtype as is_valid_na_for_dtype, isna as isna
from pandas.core.indexers import check_array_indexer as check_array_indexer, check_setitem_lengths as check_setitem_lengths
from pandas.core.ops.common import unpack_zerodim_and_defer as unpack_zerodim_and_defer
from pandas.core.ops.invalid import invalid_comparison as invalid_comparison, make_invalid_op as make_invalid_op
from pandas.errors import AbstractMethodError as AbstractMethodError, NullFrequencyError as NullFrequencyError, PerformanceWarning as PerformanceWarning
from pandas.tseries import frequencies as frequencies
from pandas.util._decorators import Appender as Appender, Substitution as Substitution, cache_readonly as cache_readonly
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Any, Literal, Sequence, TypeVar, Union, overload

DTScalarOrNaT = Union[DatetimeLikeScalar, NaTType]
DatetimeLikeArrayT = TypeVar('DatetimeLikeArrayT', bound='DatetimeLikeArrayMixin')

class InvalidComparison(Exception): ...

class DatetimeLikeArrayMixin(OpsMixin, NDArrayBackedExtensionArray):
    def __init__(self, data, dtype: Union[Dtype, None] = ..., freq: Incomplete | None = ..., copy: bool = ...) -> None: ...
    def __iter__(self): ...
    @property
    def asi8(self) -> npt.NDArray[np.int64]: ...
    def __array__(self, dtype: Union[NpDtype, None] = ...) -> np.ndarray: ...
    @overload
    def __getitem__(self, item: ScalarIndexer) -> DTScalarOrNaT: ...
    @overload
    def __getitem__(self, item: Union[SequenceIndexer, PositionalIndexerTuple]) -> DatetimeLikeArrayT: ...
    def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None: ...
    def astype(self, dtype, copy: bool = ...): ...
    @overload
    def view(self) -> DatetimeLikeArrayT: ...
    @overload
    def view(self, dtype: Literal['M8[ns]']) -> DatetimeArray: ...
    @overload
    def view(self, dtype: Literal['m8[ns]']) -> TimedeltaArray: ...
    @overload
    def view(self, dtype: Union[Dtype, None] = ...) -> ArrayLike: ...
    def copy(self, order: str = ...) -> DatetimeLikeArrayT: ...
    def map(self, mapper): ...
    def isin(self, values) -> npt.NDArray[np.bool_]: ...
    def isna(self) -> npt.NDArray[np.bool_]: ...
    @property
    def freq(self): ...
    @freq.setter
    def freq(self, value) -> None: ...
    @property
    def freqstr(self) -> Union[str, None]: ...
    @property
    def inferred_freq(self) -> Union[str, None]: ...
    @property
    def resolution(self) -> str: ...
    __pow__: Incomplete
    __rpow__: Incomplete
    __mul__: Incomplete
    __rmul__: Incomplete
    __truediv__: Incomplete
    __rtruediv__: Incomplete
    __floordiv__: Incomplete
    __rfloordiv__: Incomplete
    __mod__: Incomplete
    __rmod__: Incomplete
    __divmod__: Incomplete
    __rdivmod__: Incomplete
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __iadd__(self, other) -> DatetimeLikeArrayT: ...
    def __isub__(self, other) -> DatetimeLikeArrayT: ...
    def min(self, *, axis: Union[int, None] = ..., skipna: bool = ..., **kwargs): ...
    def max(self, *, axis: Union[int, None] = ..., skipna: bool = ..., **kwargs): ...
    def mean(self, *, skipna: bool = ..., axis: Union[int, None] = ...): ...
    def median(self, *, axis: Union[int, None] = ..., skipna: bool = ..., **kwargs): ...

class DatelikeOps(DatetimeLikeArrayMixin):
    def strftime(self, date_format: str) -> npt.NDArray[np.object_]: ...
TimelikeOpsT = TypeVar('TimelikeOpsT', bound='TimelikeOps')

class TimelikeOps(DatetimeLikeArrayMixin):
    def __init__(self, values, dtype: Incomplete | None = ..., freq=..., copy: bool = ...) -> None: ...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): ...
    def round(self, freq, ambiguous: str = ..., nonexistent: str = ...): ...
    def floor(self, freq, ambiguous: str = ..., nonexistent: str = ...): ...
    def ceil(self, freq, ambiguous: str = ..., nonexistent: str = ...): ...
    def any(self, *, axis: Union[int, None] = ..., skipna: bool = ...) -> bool: ...
    def all(self, *, axis: Union[int, None] = ..., skipna: bool = ...) -> bool: ...
    def factorize(self, na_sentinel: int = ..., sort: bool = ...): ...

def ensure_arraylike_for_datetimelike(data, copy: bool, cls_name: str): ...
@overload
def validate_periods(periods: None) -> None: ...
@overload
def validate_periods(periods: float) -> int: ...
def validate_inferred_freq(freq, inferred_freq, freq_infer) -> tuple[Union[BaseOffset, None], bool]: ...
def maybe_infer_freq(freq): ...
def dtype_to_unit(dtype: Union[DatetimeTZDtype, np.dtype]) -> str: ...
