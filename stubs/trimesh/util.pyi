import abc
import numpy as np
from _typeshed import Incomplete
from collections.abc import Mapping
from shutil import which as which

ABC = abc.ABC
PY3: Incomplete
basestring = str
log: Incomplete
TOL_ZERO: Incomplete
TOL_MERGE: float

def has_module(name): ...
def unitize(vectors, check_valid: bool = ..., threshold: Incomplete | None = ...): ...
def euclidean(a, b): ...
def is_file(obj): ...
def is_pathlib(obj): ...
def is_string(obj): ...
def is_none(obj): ...
def is_sequence(obj): ...
def is_shape(obj, shape, allow_zeros: bool = ...): ...
def make_sequence(obj): ...
def vector_hemisphere(vectors, return_sign: bool = ...): ...
def vector_to_spherical(cartesian): ...
def spherical_to_vector(spherical): ...
def pairwise(iterable): ...
multi_dot = np.linalg.multi_dot

def diagonal_dot(a, b): ...
def row_norm(data): ...
def stack_3D(points, return_2D: bool = ...): ...
def grid_arange(bounds, step): ...
def grid_linspace(bounds, count): ...
def multi_dict(pairs): ...
def tolist(data): ...
def is_binary_file(file_obj): ...
def distance_to_end(file_obj): ...
def decimal_to_digits(decimal, min_digits: Incomplete | None = ...): ...
def attach_to_log(level=..., handler: Incomplete | None = ..., loggers: Incomplete | None = ..., colors: bool = ..., capture_warnings: bool = ..., blacklist: Incomplete | None = ...) -> None: ...
def stack_lines(indices): ...
def append_faces(vertices_seq, faces_seq): ...
def array_to_string(array, col_delim: str = ..., row_delim: str = ..., digits: int = ..., value_format: str = ...): ...
def structured_array_to_string(array, col_delim: str = ..., row_delim: str = ..., digits: int = ..., value_format: str = ...): ...
def array_to_encoded(array, dtype: Incomplete | None = ..., encoding: str = ...): ...
def decode_keys(store, encoding: str = ...): ...
def comment_strip(text, starts_with: str = ..., new_line: str = ...): ...
def encoded_to_array(encoded): ...
def is_instance_named(obj, name): ...
def type_bases(obj, depth: int = ...): ...
def type_named(obj, name): ...
def concatenate(a, b: Incomplete | None = ...): ...
def submesh(mesh, faces_sequence, repair: bool = ..., only_watertight: bool = ..., min_faces: Incomplete | None = ..., append: bool = ...): ...
def zero_pad(data, count, right: bool = ...): ...
def jsonify(obj, **kwargs): ...
def convert_like(item, like): ...
def bounds_tree(bounds): ...
def wrap_as_stream(item): ...
def sigfig_round(values, sigfig: int = ...): ...
def sigfig_int(values, sigfig): ...
def decompress(file_obj, file_type): ...
def compress(info, **kwargs): ...
def split_extension(file_name, special=...): ...
def triangle_strips_to_faces(strips): ...
def vstack_empty(tup): ...
def write_encoded(file_obj, stuff, encoding: str = ...): ...
def unique_id(length: int = ...): ...
def generate_basis(z, epsilon: float = ...): ...
def isclose(a, b, atol): ...
def allclose(a, b, atol: float = ...): ...

class FunctionRegistry(Mapping):
    def __init__(self, **kwargs) -> None: ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __contains__(self, key) -> bool: ...
    def __call__(self, key, *args, **kwargs): ...

class TemporaryDirectory:
    path: Incomplete
    def __enter__(self): ...
    def __exit__(self, *args, **kwargs) -> None: ...

def decode_text(text, initial: str = ...): ...
def to_ascii(text): ...
def is_ccw(points): ...
def unique_name(start, contains): ...
